(defshards compute-specular-lut [out-name]
  {:EntryPoint (->
                (Shader.Literal :Type ShaderLiteralType.Header :Source (slurp "shaders/pbr.wgsl"))
                (Shader.ReadInput "texCoord0") >= .uv
                (Shader.Literal :OutputDimension 2 :Source ["computeLUT(" .uv ")"])
                (ToFloat2) (Shader.WriteOutput "color") ; End shader
                )}
  (GFX.EffectPass) >> .lut-steps-1
  (GFX.Texture :Format TextureFormat.RG16Float) >= out-name
  (GFX.RenderInto :Textures {:color out-name}
                  :Size (Int2 64)
                  :Contents (->
                             (GFX.Render :Steps .lut-steps-1)))
  out-name;
  )

(defshards calc-num-mips []
  (| (Take 0) >= .dim-x) (| (Take 1) >= .dim-y)
  .dim-x (Min .dim-y) >= .dim-min
  .dim-min (ToFloat) (Math.Log2) (Math.Floor) (ToInt) ; This is up until 2x2
  (Math.Add 1) ; Including 1x1
  )

(defshards generate-probes [included-steps]
  (| (Take "Queue") >= .parent-queue)
  (| (Take "View") >= .parent-view)
  (Setup (->

          (GFX.Texture :Format TextureFormat.RGBA8UnormSrgb :Resolution (Int2 1024) :Dimension TextureDimension.Cube) >= .cube-tex
          (render-cubemap included-steps .cube-tex)

  ;;         (Int2 1024) >= .size
  ;;         (Log "Cubemap dimension")
  ;;         (calc-num-mips) >= .num-mips
  ;;         (Log "Number of mip levels")

  ;;         {:EntryPoint (->
  ;;                       (Shader.ReadInput "texCoord0")
  ;;                       (ToFloat2) (Shader.WriteOutput "color") ; End shader
  ;;                       )}
  ;;         (GFX.EffectPass) >> .lut-steps
  ;;         (GFX.Texture :Format TextureFormat.RG16Float) >= .specular-lut-tex
  ;;         (GFX.RenderInto :Textures {:color .specular-lut-tex}
  ;;                         :Size (Int2 128)
  ;;                         :Contents (->
  ;;                                    (GFX.Render :Steps .lut-steps)));
          ))
  {:env .cube-tex})

(defshards setup-pbr-feature [included-steps]
  {:Params [{:Name "roughness" :Default 1.0}
            {:Name "metalicness" :Default 0.0}]
   :Shaders
   [{:Stage ProgrammableGraphicsStage.Fragment
     :After ["writeColor"]
     :Before []
     :EntryPoint
     (->
      (Shader.ReadBuffer "invView" :BufferName "view") >= .camera-matrix
      (Shader.Literal [.camera-matrix "[3].xyz"] :OutputDimension 3) >= .eye-pos
      (Shader.ReadInput "worldNormal") >= .world-normal
      (Shader.ReadInput "worldPosition") >= .world-position
      .world-position (Math.Subtract .eye-pos) (Math.Normalize) >= .incident-dir
      (Shader.Literal ["reflect(" .incident-dir "," .world-normal ")"] :OutputDimension 3) >= .reflect-dir

      (Shader.ReadBuffer "roughness") >= .roughness
      (Shader.ReadBuffer "metalicness") >= .metalicness

      (Shader.ReadGlobal "color") >= .base-color
      .world-normal (Math.Multiply (Float3 1 1 -1)) (Shader.SampleTextureCoord "env") >= .refl-color
      .roughness (Math.Lerp  .refl-color .base-color)
      ; NOTE: Because of our coordinate space with the camera viewing -Z direction
      ;       It needs to be flipped when sampling cubemaps
      (Math.Multiply (Float4 1 1 1 0)) (Math.Add (Float4 0 0 0 1))
      (Shader.WriteOutput "color"))}]} (GFX.Feature :ViewGenerators (-> (generate-probes included-steps))))
