/* automatically generated by rust-bindgen */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __MINGW64_VERSION_MAJOR: u32 = 8;
pub const __MINGW64_VERSION_MINOR: u32 = 0;
pub const __MINGW64_VERSION_BUGFIX: u32 = 0;
pub const __MINGW64_VERSION_RC: u32 = 0;
pub const __MINGW64_VERSION_STATE: &'static [u8; 6usize] = b"alpha\0";
pub const __MINGW32_MAJOR_VERSION: u32 = 3;
pub const __MINGW32_MINOR_VERSION: u32 = 11;
pub const _M_AMD64: u32 = 100;
pub const _M_X64: u32 = 100;
pub const __: u32 = 1;
pub const __MINGW_USE_UNDERSCORE_PREFIX: u32 = 0;
pub const __MINGW_HAVE_ANSI_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_PRINTF: u32 = 1;
pub const __MINGW_HAVE_ANSI_C99_SCANF: u32 = 1;
pub const __MINGW_HAVE_WIDE_C99_SCANF: u32 = 1;
pub const __MINGW_SEC_WARN_STR : & 'static [ u8 ; 92usize ] = b"This function or variable may be unsafe, use _CRT_SECURE_NO_WARNINGS to disable deprecation\0" ;
pub const __MINGW_MSVC2005_DEPREC_STR : & 'static [ u8 ; 117usize ] = b"This POSIX function is deprecated beginning in Visual C++ 2005, use _CRT_NONSTDC_NO_DEPRECATE to disable deprecation\0" ;
pub const __MINGW_FORTIFY_LEVEL: u32 = 0;
pub const __MINGW_FORTIFY_VA_ARG: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const __USE_CRTIMP: u32 = 1;
pub const USE___UUIDOF: u32 = 0;
pub const __CRT__NO_INLINE: u32 = 1;
pub const __MSVCRT_VERSION__: u32 = 1792;
pub const _WIN32_WINNT: u32 = 1537;
pub const MINGW_HAS_SECURE_API: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const MINGW_HAS_DDK_H: u32 = 1;
pub const _CRT_PACKING: u32 = 8;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 253;
pub const _ARGMAX: u32 = 100;
pub const __USE_MINGW_ANSI_STDIO: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const CBIMAGE_FLAGS_NONE: u32 = 0;
pub const CBIMAGE_FLAGS_BGRA: u32 = 1;
pub const CBIMAGE_FLAGS_PREMULTIPLIED_ALPHA: u32 = 2;
pub const CBIMAGE_FLAGS_16BITS_INT: u32 = 4;
pub const CBIMAGE_FLAGS_32BITS_FLOAT: u32 = 8;
pub const CBVAR_FLAGS_NONE: u32 = 0;
pub const CBVAR_FLAGS_USES_ALLOCATOR: u32 = 1;
pub const CBVAR_FLAGS_USES_OBJINFO: u32 = 2;
pub const CBVAR_FLAGS_REF_COUNTED: u32 = 4;
pub const CHAINBLOCKS_CURRENT_ABI: u32 = 538968321;
pub const CB_DEBUG_MODE: u32 = 1;
pub type size_t = ::std::os::raw::c_ulonglong;
pub type wchar_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
extern "C" {
    pub fn __debugbreak();
}
extern "C" {
    pub fn __mingw_get_crt_info() -> *const ::std::os::raw::c_char;
}
pub type ssize_t = ::std::os::raw::c_longlong;
pub type rsize_t = size_t;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type errno_t = ::std::os::raw::c_int;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
pub type time_t = __time64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadmbcinfostruct {
    _unused: [u8; 0],
}
pub type pthreadlocinfo = *mut threadlocaleinfostruct;
pub type pthreadmbcinfo = *mut threadmbcinfostruct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lc_time_data {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct localeinfo_struct {
    pub locinfo: pthreadlocinfo,
    pub mbcinfo: pthreadmbcinfo,
}
#[test]
fn bindgen_test_layout_localeinfo_struct() {
    assert_eq!(
        ::std::mem::size_of::<localeinfo_struct>(),
        16usize,
        concat!("Size of: ", stringify!(localeinfo_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<localeinfo_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(localeinfo_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<localeinfo_struct>())).locinfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(localeinfo_struct),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<localeinfo_struct>())).mbcinfo as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(localeinfo_struct),
            "::",
            stringify!(mbcinfo)
        )
    );
}
impl Default for localeinfo_struct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type _locale_tstruct = localeinfo_struct;
pub type _locale_t = *mut localeinfo_struct;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct tagLC_ID {
    pub wLanguage: ::std::os::raw::c_ushort,
    pub wCountry: ::std::os::raw::c_ushort,
    pub wCodePage: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout_tagLC_ID() {
    assert_eq!(
        ::std::mem::size_of::<tagLC_ID>(),
        6usize,
        concat!("Size of: ", stringify!(tagLC_ID))
    );
    assert_eq!(
        ::std::mem::align_of::<tagLC_ID>(),
        2usize,
        concat!("Alignment of ", stringify!(tagLC_ID))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagLC_ID>())).wLanguage as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wLanguage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagLC_ID>())).wCountry as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wCountry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tagLC_ID>())).wCodePage as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tagLC_ID),
            "::",
            stringify!(wCodePage)
        )
    );
}
pub type LC_ID = tagLC_ID;
pub type LPLC_ID = *mut tagLC_ID;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct {
    pub refcount: ::std::os::raw::c_int,
    pub lc_codepage: ::std::os::raw::c_uint,
    pub lc_collate_cp: ::std::os::raw::c_uint,
    pub lc_handle: [::std::os::raw::c_ulong; 6usize],
    pub lc_id: [LC_ID; 6usize],
    pub lc_category: [threadlocaleinfostruct__bindgen_ty_1; 6usize],
    pub lc_clike: ::std::os::raw::c_int,
    pub mb_cur_max: ::std::os::raw::c_int,
    pub lconv_intl_refcount: *mut ::std::os::raw::c_int,
    pub lconv_num_refcount: *mut ::std::os::raw::c_int,
    pub lconv_mon_refcount: *mut ::std::os::raw::c_int,
    pub lconv: *mut lconv,
    pub ctype1_refcount: *mut ::std::os::raw::c_int,
    pub ctype1: *mut ::std::os::raw::c_ushort,
    pub pctype: *const ::std::os::raw::c_ushort,
    pub pclmap: *const ::std::os::raw::c_uchar,
    pub pcumap: *const ::std::os::raw::c_uchar,
    pub lc_time_curr: *mut __lc_time_data,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct threadlocaleinfostruct__bindgen_ty_1 {
    pub locale: *mut ::std::os::raw::c_char,
    pub wlocale: *mut wchar_t,
    pub refcount: *mut ::std::os::raw::c_int,
    pub wrefcount: *mut ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<threadlocaleinfostruct__bindgen_ty_1>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<threadlocaleinfostruct__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).locale as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(locale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).wlocale as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(wlocale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).refcount as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct__bindgen_ty_1>())).wrefcount as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct__bindgen_ty_1),
            "::",
            stringify!(wrefcount)
        )
    );
}
impl Default for threadlocaleinfostruct__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_threadlocaleinfostruct() {
    assert_eq!(
        ::std::mem::size_of::<threadlocaleinfostruct>(),
        352usize,
        concat!("Size of: ", stringify!(threadlocaleinfostruct))
    );
    assert_eq!(
        ::std::mem::align_of::<threadlocaleinfostruct>(),
        8usize,
        concat!("Alignment of ", stringify!(threadlocaleinfostruct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).refcount as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_codepage as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_codepage)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_collate_cp as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_collate_cp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_handle as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_id as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_category as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_category)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_clike as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_clike)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).mb_cur_max as *const _ as usize
        },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(mb_cur_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).lconv_intl_refcount as *const _
                as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_intl_refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).lconv_num_refcount as *const _
                as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_num_refcount)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).lconv_mon_refcount as *const _
                as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv_mon_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).lconv as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lconv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).ctype1_refcount as *const _ as usize
        },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(ctype1_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).ctype1 as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(ctype1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).pctype as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pctype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).pclmap as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pclmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<threadlocaleinfostruct>())).pcumap as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(pcumap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<threadlocaleinfostruct>())).lc_time_curr as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(threadlocaleinfostruct),
            "::",
            stringify!(lc_time_curr)
        )
    );
}
impl Default for threadlocaleinfostruct {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type threadlocinfo = threadlocaleinfostruct;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type int_least32_t = ::std::os::raw::c_int;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type int_fast16_t = ::std::os::raw::c_short;
pub type uint_fast16_t = ::std::os::raw::c_ushort;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub const CBType_None: CBType = 0;
pub const CBType_Any: CBType = 1;
pub const CBType_Enum: CBType = 2;
pub const CBType_Bool: CBType = 3;
pub const CBType_Int: CBType = 4;
pub const CBType_Int2: CBType = 5;
pub const CBType_Int3: CBType = 6;
pub const CBType_Int4: CBType = 7;
pub const CBType_Int8: CBType = 8;
pub const CBType_Int16: CBType = 9;
pub const CBType_Float: CBType = 10;
pub const CBType_Float2: CBType = 11;
pub const CBType_Float3: CBType = 12;
pub const CBType_Float4: CBType = 13;
pub const CBType_Color: CBType = 14;
pub const CBType_Block: CBType = 15;
pub const CBType_EndOfBlittableTypes: CBType = 50;
pub const CBType_Bytes: CBType = 51;
pub const CBType_String: CBType = 52;
pub const CBType_Path: CBType = 53;
pub const CBType_ContextVar: CBType = 54;
pub const CBType_Image: CBType = 55;
pub const CBType_Seq: CBType = 56;
pub const CBType_Table: CBType = 57;
pub const CBType_Chain: CBType = 58;
pub const CBType_Object: CBType = 59;
pub const CBType_Array: CBType = 60;
pub type CBType = u8;
pub const CBChainState_Continue: CBChainState = 0;
pub const CBChainState_Return: CBChainState = 1;
pub const CBChainState_Rebase: CBChainState = 2;
pub const CBChainState_Restart: CBChainState = 3;
pub const CBChainState_Stop: CBChainState = 4;
pub type CBChainState = u8;
pub const CBInlineBlocks_NotInline: CBInlineBlocks = 0;
pub const CBInlineBlocks_NoopBlock: CBInlineBlocks = 1;
pub const CBInlineBlocks_CoreConst: CBInlineBlocks = 2;
pub const CBInlineBlocks_CoreSleep: CBInlineBlocks = 3;
pub const CBInlineBlocks_CoreInput: CBInlineBlocks = 4;
pub const CBInlineBlocks_CoreRepeat: CBInlineBlocks = 5;
pub const CBInlineBlocks_CoreOnce: CBInlineBlocks = 6;
pub const CBInlineBlocks_CoreGet: CBInlineBlocks = 7;
pub const CBInlineBlocks_CoreSet: CBInlineBlocks = 8;
pub const CBInlineBlocks_CoreRef: CBInlineBlocks = 9;
pub const CBInlineBlocks_CoreUpdate: CBInlineBlocks = 10;
pub const CBInlineBlocks_CoreSwap: CBInlineBlocks = 11;
pub const CBInlineBlocks_CoreTakeSeq: CBInlineBlocks = 12;
pub const CBInlineBlocks_CoreTakeInts: CBInlineBlocks = 13;
pub const CBInlineBlocks_CoreTakeFloats: CBInlineBlocks = 14;
pub const CBInlineBlocks_CoreTakeColor: CBInlineBlocks = 15;
pub const CBInlineBlocks_CoreTakeBytes: CBInlineBlocks = 16;
pub const CBInlineBlocks_CoreTakeString: CBInlineBlocks = 17;
pub const CBInlineBlocks_CoreTakeTable: CBInlineBlocks = 18;
pub const CBInlineBlocks_CorePush: CBInlineBlocks = 19;
pub const CBInlineBlocks_CoreIs: CBInlineBlocks = 20;
pub const CBInlineBlocks_CoreIsNot: CBInlineBlocks = 21;
pub const CBInlineBlocks_CoreAnd: CBInlineBlocks = 22;
pub const CBInlineBlocks_CoreOr: CBInlineBlocks = 23;
pub const CBInlineBlocks_CoreNot: CBInlineBlocks = 24;
pub const CBInlineBlocks_CoreIsMore: CBInlineBlocks = 25;
pub const CBInlineBlocks_CoreIsLess: CBInlineBlocks = 26;
pub const CBInlineBlocks_CoreIsMoreEqual: CBInlineBlocks = 27;
pub const CBInlineBlocks_CoreIsLessEqual: CBInlineBlocks = 28;
pub const CBInlineBlocks_MathAdd: CBInlineBlocks = 29;
pub const CBInlineBlocks_MathSubtract: CBInlineBlocks = 30;
pub const CBInlineBlocks_MathMultiply: CBInlineBlocks = 31;
pub const CBInlineBlocks_MathDivide: CBInlineBlocks = 32;
pub const CBInlineBlocks_MathXor: CBInlineBlocks = 33;
pub const CBInlineBlocks_MathAnd: CBInlineBlocks = 34;
pub const CBInlineBlocks_MathOr: CBInlineBlocks = 35;
pub const CBInlineBlocks_MathMod: CBInlineBlocks = 36;
pub const CBInlineBlocks_MathLShift: CBInlineBlocks = 37;
pub const CBInlineBlocks_MathRShift: CBInlineBlocks = 38;
pub const CBInlineBlocks_MathAbs: CBInlineBlocks = 39;
pub const CBInlineBlocks_MathExp: CBInlineBlocks = 40;
pub const CBInlineBlocks_MathExp2: CBInlineBlocks = 41;
pub const CBInlineBlocks_MathExpm1: CBInlineBlocks = 42;
pub const CBInlineBlocks_MathLog: CBInlineBlocks = 43;
pub const CBInlineBlocks_MathLog10: CBInlineBlocks = 44;
pub const CBInlineBlocks_MathLog2: CBInlineBlocks = 45;
pub const CBInlineBlocks_MathLog1p: CBInlineBlocks = 46;
pub const CBInlineBlocks_MathSqrt: CBInlineBlocks = 47;
pub const CBInlineBlocks_MathCbrt: CBInlineBlocks = 48;
pub const CBInlineBlocks_MathSin: CBInlineBlocks = 49;
pub const CBInlineBlocks_MathCos: CBInlineBlocks = 50;
pub const CBInlineBlocks_MathTan: CBInlineBlocks = 51;
pub const CBInlineBlocks_MathAsin: CBInlineBlocks = 52;
pub const CBInlineBlocks_MathAcos: CBInlineBlocks = 53;
pub const CBInlineBlocks_MathAtan: CBInlineBlocks = 54;
pub const CBInlineBlocks_MathSinh: CBInlineBlocks = 55;
pub const CBInlineBlocks_MathCosh: CBInlineBlocks = 56;
pub const CBInlineBlocks_MathTanh: CBInlineBlocks = 57;
pub const CBInlineBlocks_MathAsinh: CBInlineBlocks = 58;
pub const CBInlineBlocks_MathAcosh: CBInlineBlocks = 59;
pub const CBInlineBlocks_MathAtanh: CBInlineBlocks = 60;
pub const CBInlineBlocks_MathErf: CBInlineBlocks = 61;
pub const CBInlineBlocks_MathErfc: CBInlineBlocks = 62;
pub const CBInlineBlocks_MathTGamma: CBInlineBlocks = 63;
pub const CBInlineBlocks_MathLGamma: CBInlineBlocks = 64;
pub const CBInlineBlocks_MathCeil: CBInlineBlocks = 65;
pub const CBInlineBlocks_MathFloor: CBInlineBlocks = 66;
pub const CBInlineBlocks_MathTrunc: CBInlineBlocks = 67;
pub const CBInlineBlocks_MathRound: CBInlineBlocks = 68;
pub type CBInlineBlocks = u32;
pub type CBArray = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBSeq {
    pub elements: *mut CBVar,
    pub len: u32,
    pub cap: u32,
}
#[test]
fn bindgen_test_layout_CBSeq() {
    assert_eq!(
        ::std::mem::size_of::<CBSeq>(),
        16usize,
        concat!("Size of: ", stringify!(CBSeq))
    );
    assert_eq!(
        ::std::mem::align_of::<CBSeq>(),
        8usize,
        concat!("Alignment of ", stringify!(CBSeq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBSeq>())).elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBSeq),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBSeq>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBSeq),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBSeq>())).cap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBSeq),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for CBSeq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CBTableIterator = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBTable {
    pub opaque: *mut ::std::os::raw::c_void,
    pub api: *mut CBTableInterface,
}
#[test]
fn bindgen_test_layout_CBTable() {
    assert_eq!(
        ::std::mem::size_of::<CBTable>(),
        16usize,
        concat!("Size of: ", stringify!(CBTable))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTable>(),
        8usize,
        concat!("Alignment of ", stringify!(CBTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTable>())).opaque as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTable),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTable>())).api as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTable),
            "::",
            stringify!(api)
        )
    );
}
impl Default for CBTable {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBChain {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBChainRefOpaque {
    _unused: [u8; 0],
}
pub type CBChainRef = *mut CBChainRefOpaque;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBNode {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBNodeRefOpaque {
    _unused: [u8; 0],
}
pub type CBNodeRef = *mut CBNodeRefOpaque;
pub type CBlockPtr = *mut CBlock;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBlocks {
    pub elements: *mut CBlockPtr,
    pub len: u32,
    pub cap: u32,
}
#[test]
fn bindgen_test_layout_CBlocks() {
    assert_eq!(
        ::std::mem::size_of::<CBlocks>(),
        16usize,
        concat!("Size of: ", stringify!(CBlocks))
    );
    assert_eq!(
        ::std::mem::align_of::<CBlocks>(),
        8usize,
        concat!("Alignment of ", stringify!(CBlocks))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlocks>())).elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlocks),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlocks>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlocks),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlocks>())).cap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlocks),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for CBlocks {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBTypesInfo {
    pub elements: *mut CBTypeInfo,
    pub len: u32,
    pub cap: u32,
}
#[test]
fn bindgen_test_layout_CBTypesInfo() {
    assert_eq!(
        ::std::mem::size_of::<CBTypesInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CBTypesInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTypesInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CBTypesInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypesInfo>())).elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypesInfo),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypesInfo>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypesInfo),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypesInfo>())).cap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypesInfo),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for CBTypesInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBParametersInfo {
    pub elements: *mut CBParameterInfo,
    pub len: u32,
    pub cap: u32,
}
#[test]
fn bindgen_test_layout_CBParametersInfo() {
    assert_eq!(
        ::std::mem::size_of::<CBParametersInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CBParametersInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CBParametersInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CBParametersInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBParametersInfo>())).elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBParametersInfo),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBParametersInfo>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBParametersInfo),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBParametersInfo>())).cap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBParametersInfo),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for CBParametersInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBExposedTypesInfo {
    pub elements: *mut CBExposedTypeInfo,
    pub len: u32,
    pub cap: u32,
}
#[test]
fn bindgen_test_layout_CBExposedTypesInfo() {
    assert_eq!(
        ::std::mem::size_of::<CBExposedTypesInfo>(),
        16usize,
        concat!("Size of: ", stringify!(CBExposedTypesInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CBExposedTypesInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CBExposedTypesInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypesInfo>())).elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypesInfo),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypesInfo>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypesInfo),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypesInfo>())).cap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypesInfo),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for CBExposedTypesInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CBPointer = *mut ::std::os::raw::c_void;
pub type CBInt = i64;
pub type CBFloat = f64;
pub type CBBool = bool;
pub type CBEnum = i32;
pub type CBString = *const ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBStrings {
    pub elements: *mut CBString,
    pub len: u32,
    pub cap: u32,
}
#[test]
fn bindgen_test_layout_CBStrings() {
    assert_eq!(
        ::std::mem::size_of::<CBStrings>(),
        16usize,
        concat!("Size of: ", stringify!(CBStrings))
    );
    assert_eq!(
        ::std::mem::align_of::<CBStrings>(),
        8usize,
        concat!("Alignment of ", stringify!(CBStrings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBStrings>())).elements as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBStrings),
            "::",
            stringify!(elements)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBStrings>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBStrings),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBStrings>())).cap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBStrings),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for CBStrings {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CBInt2 = [i64; 2usize];
pub type CBInt3 = [i32; 4usize];
pub type CBInt4 = [i32; 4usize];
pub type CBInt8 = [i16; 8usize];
pub type CBInt16 = [i8; 16usize];
pub type CBFloat2 = [f64; 2usize];
pub type CBFloat3 = [f32; 4usize];
pub type CBFloat4 = [f32; 4usize];
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBColor {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}
#[test]
fn bindgen_test_layout_CBColor() {
    assert_eq!(
        ::std::mem::size_of::<CBColor>(),
        4usize,
        concat!("Size of: ", stringify!(CBColor))
    );
    assert_eq!(
        ::std::mem::align_of::<CBColor>(),
        1usize,
        concat!("Alignment of ", stringify!(CBColor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBColor>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBColor),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBColor>())).g as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(CBColor),
            "::",
            stringify!(g)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBColor>())).b as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CBColor),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBColor>())).a as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(CBColor),
            "::",
            stringify!(a)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBImage {
    pub width: u16,
    pub height: u16,
    pub channels: u8,
    pub flags: u8,
    pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_CBImage() {
    assert_eq!(
        ::std::mem::size_of::<CBImage>(),
        16usize,
        concat!("Size of: ", stringify!(CBImage))
    );
    assert_eq!(
        ::std::mem::align_of::<CBImage>(),
        8usize,
        concat!("Alignment of ", stringify!(CBImage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBImage>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBImage),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBImage>())).height as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(CBImage),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBImage>())).channels as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CBImage),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBImage>())).flags as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(CBImage),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBImage>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBImage),
            "::",
            stringify!(data)
        )
    );
}
impl Default for CBImage {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBAudio {
    pub sampleRate: f32,
    pub nsamples: u16,
    pub channels: u16,
    pub samples: *mut f32,
}
#[test]
fn bindgen_test_layout_CBAudio() {
    assert_eq!(
        ::std::mem::size_of::<CBAudio>(),
        16usize,
        concat!("Size of: ", stringify!(CBAudio))
    );
    assert_eq!(
        ::std::mem::align_of::<CBAudio>(),
        8usize,
        concat!("Alignment of ", stringify!(CBAudio))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBAudio>())).sampleRate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBAudio),
            "::",
            stringify!(sampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBAudio>())).nsamples as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CBAudio),
            "::",
            stringify!(nsamples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBAudio>())).channels as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(CBAudio),
            "::",
            stringify!(channels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBAudio>())).samples as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBAudio),
            "::",
            stringify!(samples)
        )
    );
}
impl Default for CBAudio {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CBTableForEachCallback = ::std::option::Option<
    unsafe extern "C" fn(
        key: *const ::std::os::raw::c_char,
        value: *mut CBVar,
        userData: *mut ::std::os::raw::c_void,
    ) -> CBBool,
>;
pub type CBTableForEach = ::std::option::Option<
    unsafe extern "C" fn(
        table: CBTable,
        cb: CBTableForEachCallback,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
pub type CBTableSize = ::std::option::Option<unsafe extern "C" fn(table: CBTable) -> size_t>;
pub type CBTableContains = ::std::option::Option<
    unsafe extern "C" fn(table: CBTable, key: *const ::std::os::raw::c_char) -> CBBool,
>;
pub type CBTableAt = ::std::option::Option<
    unsafe extern "C" fn(table: CBTable, key: *const ::std::os::raw::c_char) -> *mut CBVar,
>;
pub type CBTableRemove =
    ::std::option::Option<unsafe extern "C" fn(table: CBTable, key: *const ::std::os::raw::c_char)>;
pub type CBTableClear = ::std::option::Option<unsafe extern "C" fn(table: CBTable)>;
pub type CBTableFree = ::std::option::Option<unsafe extern "C" fn(table: CBTable)>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBTableInterface {
    pub tableForEach: CBTableForEach,
    pub tableSize: CBTableSize,
    pub tableContains: CBTableContains,
    pub tableAt: CBTableAt,
    pub tableRemove: CBTableRemove,
    pub tableClear: CBTableClear,
    pub tableFree: CBTableFree,
}
#[test]
fn bindgen_test_layout_CBTableInterface() {
    assert_eq!(
        ::std::mem::size_of::<CBTableInterface>(),
        56usize,
        concat!("Size of: ", stringify!(CBTableInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTableInterface>(),
        8usize,
        concat!("Alignment of ", stringify!(CBTableInterface))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTableInterface>())).tableForEach as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTableInterface),
            "::",
            stringify!(tableForEach)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTableInterface>())).tableSize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTableInterface),
            "::",
            stringify!(tableSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTableInterface>())).tableContains as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTableInterface),
            "::",
            stringify!(tableContains)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTableInterface>())).tableAt as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTableInterface),
            "::",
            stringify!(tableAt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTableInterface>())).tableRemove as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTableInterface),
            "::",
            stringify!(tableRemove)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTableInterface>())).tableClear as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTableInterface),
            "::",
            stringify!(tableClear)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTableInterface>())).tableFree as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTableInterface),
            "::",
            stringify!(tableFree)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBAllocatorInterface {}
#[test]
fn bindgen_test_layout_CBAllocatorInterface() {
    assert_eq!(
        ::std::mem::size_of::<CBAllocatorInterface>(),
        0usize,
        concat!("Size of: ", stringify!(CBAllocatorInterface))
    );
    assert_eq!(
        ::std::mem::align_of::<CBAllocatorInterface>(),
        1usize,
        concat!("Alignment of ", stringify!(CBAllocatorInterface))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CBTypeInfo {
    pub basicType: CBType,
    pub details: CBTypeInfo_Details,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CBTypeInfo_Details {
    pub object: CBTypeInfo_Details_Object,
    pub enumeration: CBTypeInfo_Details_Enum,
    pub seqTypes: CBTypesInfo,
    pub table: CBTypeInfo_Details_Table,
    pub contextVarTypes: CBTypesInfo,
    pub path: CBTypeInfo_Details_Path,
    pub integers: CBTypeInfo_Details_Integers,
    pub real: CBTypeInfo_Details_Real,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBTypeInfo_Details_Object {
    pub vendorId: i32,
    pub typeId: i32,
}
#[test]
fn bindgen_test_layout_CBTypeInfo_Details_Object() {
    assert_eq!(
        ::std::mem::size_of::<CBTypeInfo_Details_Object>(),
        8usize,
        concat!("Size of: ", stringify!(CBTypeInfo_Details_Object))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTypeInfo_Details_Object>(),
        4usize,
        concat!("Alignment of ", stringify!(CBTypeInfo_Details_Object))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBTypeInfo_Details_Object>())).vendorId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Object),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBTypeInfo_Details_Object>())).typeId as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Object),
            "::",
            stringify!(typeId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBTypeInfo_Details_Enum {
    pub vendorId: i32,
    pub typeId: i32,
}
#[test]
fn bindgen_test_layout_CBTypeInfo_Details_Enum() {
    assert_eq!(
        ::std::mem::size_of::<CBTypeInfo_Details_Enum>(),
        8usize,
        concat!("Size of: ", stringify!(CBTypeInfo_Details_Enum))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTypeInfo_Details_Enum>(),
        4usize,
        concat!("Alignment of ", stringify!(CBTypeInfo_Details_Enum))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBTypeInfo_Details_Enum>())).vendorId as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Enum),
            "::",
            stringify!(vendorId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details_Enum>())).typeId as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Enum),
            "::",
            stringify!(typeId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBTypeInfo_Details_Table {
    pub keys: CBStrings,
    pub types: CBTypesInfo,
}
#[test]
fn bindgen_test_layout_CBTypeInfo_Details_Table() {
    assert_eq!(
        ::std::mem::size_of::<CBTypeInfo_Details_Table>(),
        32usize,
        concat!("Size of: ", stringify!(CBTypeInfo_Details_Table))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTypeInfo_Details_Table>(),
        8usize,
        concat!("Alignment of ", stringify!(CBTypeInfo_Details_Table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details_Table>())).keys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Table),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details_Table>())).types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Table),
            "::",
            stringify!(types)
        )
    );
}
impl Default for CBTypeInfo_Details_Table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBTypeInfo_Details_Path {
    pub extensions: CBStrings,
    pub isFile: CBBool,
    pub existing: CBBool,
    pub relative: CBBool,
}
#[test]
fn bindgen_test_layout_CBTypeInfo_Details_Path() {
    assert_eq!(
        ::std::mem::size_of::<CBTypeInfo_Details_Path>(),
        24usize,
        concat!("Size of: ", stringify!(CBTypeInfo_Details_Path))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTypeInfo_Details_Path>(),
        8usize,
        concat!("Alignment of ", stringify!(CBTypeInfo_Details_Path))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBTypeInfo_Details_Path>())).extensions as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Path),
            "::",
            stringify!(extensions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details_Path>())).isFile as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Path),
            "::",
            stringify!(isFile)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBTypeInfo_Details_Path>())).existing as *const _ as usize
        },
        17usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Path),
            "::",
            stringify!(existing)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBTypeInfo_Details_Path>())).relative as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Path),
            "::",
            stringify!(relative)
        )
    );
}
impl Default for CBTypeInfo_Details_Path {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBTypeInfo_Details_Integers {
    pub min: i64,
    pub max: i64,
    pub valid: CBBool,
}
#[test]
fn bindgen_test_layout_CBTypeInfo_Details_Integers() {
    assert_eq!(
        ::std::mem::size_of::<CBTypeInfo_Details_Integers>(),
        24usize,
        concat!("Size of: ", stringify!(CBTypeInfo_Details_Integers))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTypeInfo_Details_Integers>(),
        8usize,
        concat!("Alignment of ", stringify!(CBTypeInfo_Details_Integers))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details_Integers>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Integers),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details_Integers>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Integers),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBTypeInfo_Details_Integers>())).valid as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Integers),
            "::",
            stringify!(valid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBTypeInfo_Details_Real {
    pub min: f64,
    pub max: f64,
    pub valid: CBBool,
}
#[test]
fn bindgen_test_layout_CBTypeInfo_Details_Real() {
    assert_eq!(
        ::std::mem::size_of::<CBTypeInfo_Details_Real>(),
        24usize,
        concat!("Size of: ", stringify!(CBTypeInfo_Details_Real))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTypeInfo_Details_Real>(),
        8usize,
        concat!("Alignment of ", stringify!(CBTypeInfo_Details_Real))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details_Real>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Real),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details_Real>())).max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Real),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details_Real>())).valid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details_Real),
            "::",
            stringify!(valid)
        )
    );
}
#[test]
fn bindgen_test_layout_CBTypeInfo_Details() {
    assert_eq!(
        ::std::mem::size_of::<CBTypeInfo_Details>(),
        32usize,
        concat!("Size of: ", stringify!(CBTypeInfo_Details))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTypeInfo_Details>(),
        8usize,
        concat!("Alignment of ", stringify!(CBTypeInfo_Details))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details>())).object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details),
            "::",
            stringify!(object)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details>())).enumeration as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details),
            "::",
            stringify!(enumeration)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details>())).seqTypes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details),
            "::",
            stringify!(seqTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details>())).table as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBTypeInfo_Details>())).contextVarTypes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details),
            "::",
            stringify!(contextVarTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details>())).integers as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details),
            "::",
            stringify!(integers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo_Details>())).real as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo_Details),
            "::",
            stringify!(real)
        )
    );
}
impl Default for CBTypeInfo_Details {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CBTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<CBTypeInfo>(),
        40usize,
        concat!("Size of: ", stringify!(CBTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CBTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CBTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo>())).basicType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo),
            "::",
            stringify!(basicType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBTypeInfo>())).details as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBTypeInfo),
            "::",
            stringify!(details)
        )
    );
}
impl Default for CBTypeInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CBObjectSerializer = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: CBPointer,
        outData: *mut *mut u8,
        outLen: *mut size_t,
        customHandle: *mut CBPointer,
    ) -> CBBool,
>;
pub type CBObjectSerializerFree =
    ::std::option::Option<unsafe extern "C" fn(customHandle: CBPointer)>;
pub type CBObjectDeserializer =
    ::std::option::Option<unsafe extern "C" fn(data: *mut u8, len: size_t) -> CBPointer>;
pub type CBObjectReference = ::std::option::Option<unsafe extern "C" fn(arg1: CBPointer)>;
pub type CBObjectRelease = ::std::option::Option<unsafe extern "C" fn(arg1: CBPointer)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBObjectInfo {
    pub name: *const ::std::os::raw::c_char,
    pub serialize: CBObjectSerializer,
    pub free: CBObjectSerializerFree,
    pub deserialize: CBObjectDeserializer,
    pub reference: CBObjectReference,
    pub release: CBObjectRelease,
}
#[test]
fn bindgen_test_layout_CBObjectInfo() {
    assert_eq!(
        ::std::mem::size_of::<CBObjectInfo>(),
        48usize,
        concat!("Size of: ", stringify!(CBObjectInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CBObjectInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CBObjectInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBObjectInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBObjectInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBObjectInfo>())).serialize as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBObjectInfo),
            "::",
            stringify!(serialize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBObjectInfo>())).free as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBObjectInfo),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBObjectInfo>())).deserialize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CBObjectInfo),
            "::",
            stringify!(deserialize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBObjectInfo>())).reference as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CBObjectInfo),
            "::",
            stringify!(reference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBObjectInfo>())).release as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CBObjectInfo),
            "::",
            stringify!(release)
        )
    );
}
impl Default for CBObjectInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBEnumInfo {
    pub name: *const ::std::os::raw::c_char,
    pub labels: CBStrings,
}
#[test]
fn bindgen_test_layout_CBEnumInfo() {
    assert_eq!(
        ::std::mem::size_of::<CBEnumInfo>(),
        24usize,
        concat!("Size of: ", stringify!(CBEnumInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CBEnumInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CBEnumInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBEnumInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBEnumInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBEnumInfo>())).labels as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBEnumInfo),
            "::",
            stringify!(labels)
        )
    );
}
impl Default for CBEnumInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBParameterInfo {
    pub name: *const ::std::os::raw::c_char,
    pub help: *const ::std::os::raw::c_char,
    pub valueTypes: CBTypesInfo,
}
#[test]
fn bindgen_test_layout_CBParameterInfo() {
    assert_eq!(
        ::std::mem::size_of::<CBParameterInfo>(),
        32usize,
        concat!("Size of: ", stringify!(CBParameterInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CBParameterInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CBParameterInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBParameterInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBParameterInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBParameterInfo>())).help as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBParameterInfo),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBParameterInfo>())).valueTypes as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBParameterInfo),
            "::",
            stringify!(valueTypes)
        )
    );
}
impl Default for CBParameterInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CBExposedTypeInfo {
    pub name: *const ::std::os::raw::c_char,
    pub help: *const ::std::os::raw::c_char,
    pub exposedType: CBTypeInfo,
    pub isMutable: CBBool,
    pub isTableEntry: CBBool,
    pub global: CBBool,
    pub scope: *mut CBChain,
}
#[test]
fn bindgen_test_layout_CBExposedTypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<CBExposedTypeInfo>(),
        72usize,
        concat!("Size of: ", stringify!(CBExposedTypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CBExposedTypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CBExposedTypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypeInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypeInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypeInfo>())).help as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypeInfo),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypeInfo>())).exposedType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypeInfo),
            "::",
            stringify!(exposedType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypeInfo>())).isMutable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypeInfo),
            "::",
            stringify!(isMutable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypeInfo>())).isTableEntry as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypeInfo),
            "::",
            stringify!(isTableEntry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypeInfo>())).global as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypeInfo),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBExposedTypeInfo>())).scope as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CBExposedTypeInfo),
            "::",
            stringify!(scope)
        )
    );
}
impl Default for CBExposedTypeInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CBValidationResult {
    pub outputType: CBTypeInfo,
    pub exposedInfo: CBExposedTypesInfo,
    pub requiredInfo: CBExposedTypesInfo,
    pub flowStopper: bool,
}
#[test]
fn bindgen_test_layout_CBValidationResult() {
    assert_eq!(
        ::std::mem::size_of::<CBValidationResult>(),
        80usize,
        concat!("Size of: ", stringify!(CBValidationResult))
    );
    assert_eq!(
        ::std::mem::align_of::<CBValidationResult>(),
        8usize,
        concat!("Alignment of ", stringify!(CBValidationResult))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBValidationResult>())).outputType as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBValidationResult),
            "::",
            stringify!(outputType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBValidationResult>())).exposedInfo as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CBValidationResult),
            "::",
            stringify!(exposedInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBValidationResult>())).requiredInfo as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CBValidationResult),
            "::",
            stringify!(requiredInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBValidationResult>())).flowStopper as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CBValidationResult),
            "::",
            stringify!(flowStopper)
        )
    );
}
impl Default for CBValidationResult {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBFlow {
    pub chain: *mut CBChain,
}
#[test]
fn bindgen_test_layout_CBFlow() {
    assert_eq!(
        ::std::mem::size_of::<CBFlow>(),
        8usize,
        concat!("Size of: ", stringify!(CBFlow))
    );
    assert_eq!(
        ::std::mem::align_of::<CBFlow>(),
        8usize,
        concat!("Alignment of ", stringify!(CBFlow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBFlow>())).chain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBFlow),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for CBFlow {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct CBVarPayload {
    pub __bindgen_anon_1: CBVarPayload__bindgen_ty_1,
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub union CBVarPayload__bindgen_ty_1 {
    pub boolValue: CBBool,
    pub __bindgen_anon_1: CBVarPayload__bindgen_ty_1__bindgen_ty_1,
    pub intValue: CBInt,
    pub int2Value: CBInt2,
    pub int3Value: CBInt3,
    pub int4Value: CBInt4,
    pub int8Value: CBInt8,
    pub int16Value: CBInt16,
    pub floatValue: CBFloat,
    pub float2Value: CBFloat2,
    pub float3Value: CBFloat3,
    pub float4Value: CBFloat4,
    pub seqValue: CBSeq,
    pub tableValue: CBTable,
    pub __bindgen_anon_2: CBVarPayload__bindgen_ty_1__bindgen_ty_2,
    pub colorValue: CBColor,
    pub imageValue: CBImage,
    pub audioValue: CBAudio,
    pub chainValue: CBChainRef,
    pub blockValue: CBlockPtr,
    pub __bindgen_anon_3: CBVarPayload__bindgen_ty_1__bindgen_ty_3,
    pub __bindgen_anon_4: CBVarPayload__bindgen_ty_1__bindgen_ty_4,
    pub __bindgen_anon_5: CBVarPayload__bindgen_ty_1__bindgen_ty_5,
    _bindgen_union_align: u128,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBVarPayload__bindgen_ty_1__bindgen_ty_1 {
    pub objectValue: CBPointer,
    pub objectVendorId: i32,
    pub objectTypeId: i32,
}
#[test]
fn bindgen_test_layout_CBVarPayload__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_1>())).objectValue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(objectValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_1>())).objectVendorId
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(objectVendorId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_1>())).objectTypeId
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(objectTypeId)
        )
    );
}
impl Default for CBVarPayload__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBVarPayload__bindgen_ty_1__bindgen_ty_2 {
    pub stringValue: CBString,
    pub stringLen: u32,
    pub stringCapacity: u32,
}
#[test]
fn bindgen_test_layout_CBVarPayload__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_2>())).stringValue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(stringValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_2>())).stringLen
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(stringLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_2>())).stringCapacity
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(stringCapacity)
        )
    );
}
impl Default for CBVarPayload__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBVarPayload__bindgen_ty_1__bindgen_ty_3 {
    pub enumValue: CBEnum,
    pub enumVendorId: i32,
    pub enumTypeId: i32,
}
#[test]
fn bindgen_test_layout_CBVarPayload__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_3>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_3>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_3>())).enumValue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(enumValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_3>())).enumVendorId
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(enumVendorId)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_3>())).enumTypeId
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(enumTypeId)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBVarPayload__bindgen_ty_1__bindgen_ty_4 {
    pub bytesValue: *mut u8,
    pub bytesSize: u32,
    pub bytesCapacity: u32,
}
#[test]
fn bindgen_test_layout_CBVarPayload__bindgen_ty_1__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_4>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_4>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_4>())).bytesValue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(bytesValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_4>())).bytesSize
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(bytesSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_4>())).bytesCapacity
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_4),
            "::",
            stringify!(bytesCapacity)
        )
    );
}
impl Default for CBVarPayload__bindgen_ty_1__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBVarPayload__bindgen_ty_1__bindgen_ty_5 {
    pub arrayValue: *mut CBVarPayload,
    pub arrayLen: u32,
    pub arrayCapacity: u32,
}
#[test]
fn bindgen_test_layout_CBVarPayload__bindgen_ty_1__bindgen_ty_5() {
    assert_eq!(
        ::std::mem::size_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_5>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<CBVarPayload__bindgen_ty_1__bindgen_ty_5>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_5)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_5>())).arrayValue
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(arrayValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_5>())).arrayLen
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(arrayLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1__bindgen_ty_5>())).arrayCapacity
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1__bindgen_ty_5),
            "::",
            stringify!(arrayCapacity)
        )
    );
}
impl Default for CBVarPayload__bindgen_ty_1__bindgen_ty_5 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CBVarPayload__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CBVarPayload__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(CBVarPayload__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CBVarPayload__bindgen_ty_1>(),
        16usize,
        concat!("Alignment of ", stringify!(CBVarPayload__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).boolValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(boolValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).intValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(intValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).int2Value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(int2Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).int3Value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(int3Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).int4Value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(int4Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).int8Value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(int8Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).int16Value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(int16Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).floatValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(floatValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).float2Value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(float2Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).float3Value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(float3Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).float4Value as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(float4Value)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).seqValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(seqValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).tableValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(tableValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).colorValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(colorValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).imageValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(imageValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).audioValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(audioValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).chainValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(chainValue)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBVarPayload__bindgen_ty_1>())).blockValue as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVarPayload__bindgen_ty_1),
            "::",
            stringify!(blockValue)
        )
    );
}
impl Default for CBVarPayload__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CBVarPayload() {
    assert_eq!(
        ::std::mem::size_of::<CBVarPayload>(),
        16usize,
        concat!("Size of: ", stringify!(CBVarPayload))
    );
    assert_eq!(
        ::std::mem::align_of::<CBVarPayload>(),
        16usize,
        concat!("Alignment of ", stringify!(CBVarPayload))
    );
}
impl Default for CBVarPayload {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct CBVar {
    pub payload: CBVarPayload,
    pub __bindgen_anon_1: CBVar__bindgen_ty_1,
    pub refcount: u32,
    pub valueType: CBType,
    pub innerType: CBType,
    pub flags: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union CBVar__bindgen_ty_1 {
    pub objectInfo: *mut CBObjectInfo,
    pub allocator: *mut CBAllocatorInterface,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_CBVar__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<CBVar__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(CBVar__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<CBVar__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(CBVar__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBVar__bindgen_ty_1>())).objectInfo as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVar__bindgen_ty_1),
            "::",
            stringify!(objectInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBVar__bindgen_ty_1>())).allocator as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVar__bindgen_ty_1),
            "::",
            stringify!(allocator)
        )
    );
}
impl Default for CBVar__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_CBVar() {
    assert_eq!(
        ::std::mem::size_of::<CBVar>(),
        32usize,
        concat!("Size of: ", stringify!(CBVar))
    );
    assert_eq!(
        ::std::mem::align_of::<CBVar>(),
        16usize,
        concat!("Alignment of ", stringify!(CBVar))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBVar>())).payload as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVar),
            "::",
            stringify!(payload)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBVar>())).refcount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVar),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBVar>())).valueType as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVar),
            "::",
            stringify!(valueType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBVar>())).innerType as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVar),
            "::",
            stringify!(innerType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBVar>())).flags as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(CBVar),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for CBVar {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const CBRunChainOutputState_Running: CBRunChainOutputState = 0;
pub const CBRunChainOutputState_Restarted: CBRunChainOutputState = 1;
pub const CBRunChainOutputState_Stopped: CBRunChainOutputState = 2;
pub const CBRunChainOutputState_Failed: CBRunChainOutputState = 3;
pub type CBRunChainOutputState = u32;
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct CBRunChainOutput {
    pub output: CBVar,
    pub state: CBRunChainOutputState,
}
#[test]
fn bindgen_test_layout_CBRunChainOutput() {
    assert_eq!(
        ::std::mem::size_of::<CBRunChainOutput>(),
        48usize,
        concat!("Size of: ", stringify!(CBRunChainOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<CBRunChainOutput>(),
        16usize,
        concat!("Alignment of ", stringify!(CBRunChainOutput))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBRunChainOutput>())).output as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBRunChainOutput),
            "::",
            stringify!(output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBRunChainOutput>())).state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CBRunChainOutput),
            "::",
            stringify!(state)
        )
    );
}
impl Default for CBRunChainOutput {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct CBInstanceData {
    pub block: *mut CBlock,
    pub chain: *mut CBChain,
    pub inputType: CBTypeInfo,
    pub stack: CBTypesInfo,
    pub shared: CBExposedTypesInfo,
    pub outputTypes: CBTypesInfo,
}
#[test]
fn bindgen_test_layout_CBInstanceData() {
    assert_eq!(
        ::std::mem::size_of::<CBInstanceData>(),
        104usize,
        concat!("Size of: ", stringify!(CBInstanceData))
    );
    assert_eq!(
        ::std::mem::align_of::<CBInstanceData>(),
        8usize,
        concat!("Alignment of ", stringify!(CBInstanceData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBInstanceData>())).block as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBInstanceData),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBInstanceData>())).chain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBInstanceData),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBInstanceData>())).inputType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBInstanceData),
            "::",
            stringify!(inputType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBInstanceData>())).stack as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CBInstanceData),
            "::",
            stringify!(stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBInstanceData>())).shared as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CBInstanceData),
            "::",
            stringify!(shared)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBInstanceData>())).outputTypes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CBInstanceData),
            "::",
            stringify!(outputTypes)
        )
    );
}
impl Default for CBInstanceData {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CBBlockConstructor = ::std::option::Option<unsafe extern "C" fn() -> *mut CBlock>;
pub type CBCallback = ::std::option::Option<unsafe extern "C" fn()>;
pub type CBNameProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock) -> *const ::std::os::raw::c_char>;
pub type CBHelpProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock) -> *const ::std::os::raw::c_char>;
pub type CBSetupProc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock)>;
pub type CBDestroyProc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock)>;
pub type CBInputTypesProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock) -> CBTypesInfo>;
pub type CBOutputTypesProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock) -> CBTypesInfo>;
pub type CBExposedVariablesProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock) -> CBExposedTypesInfo>;
pub type CBRequiredVariablesProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock) -> CBExposedTypesInfo>;
pub type CBParametersProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock) -> CBParametersInfo>;
pub type CBSetParamProc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBlock, arg2: ::std::os::raw::c_int, arg3: CBVar),
>;
pub type CBGetParamProc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBlock, arg2: ::std::os::raw::c_int) -> CBVar,
>;
pub type CBComposeProc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBlock, data: CBInstanceData) -> CBTypeInfo,
>;
pub type CBComposedProc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBlock, chain: *const CBChain, data: *const CBValidationResult),
>;
pub type CBActivateProc = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBlock, arg2: *mut CBContext, arg3: *const CBVar) -> CBVar,
>;
pub type CBCleanupProc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock)>;
pub type CBWarmupProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock, arg2: *mut CBContext)>;
pub type CBMutateProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock, options: CBTable)>;
pub type CBCrossoverProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock, state0: CBVar, state1: CBVar)>;
pub type CBGetStateProc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock) -> CBVar>;
pub type CBSetStateProc =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock, state: CBVar)>;
pub type CBResetStateProc = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlock)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBlock {
    pub inlineBlockId: CBInlineBlocks,
    pub owned: CBBool,
    pub name: CBNameProc,
    pub help: CBHelpProc,
    pub setup: CBSetupProc,
    pub destroy: CBDestroyProc,
    pub inputTypes: CBInputTypesProc,
    pub outputTypes: CBOutputTypesProc,
    pub exposedVariables: CBExposedVariablesProc,
    pub requiredVariables: CBRequiredVariablesProc,
    pub compose: CBComposeProc,
    pub composed: CBComposedProc,
    pub parameters: CBParametersProc,
    pub setParam: CBSetParamProc,
    pub getParam: CBGetParamProc,
    pub warmup: CBWarmupProc,
    pub activate: CBActivateProc,
    pub cleanup: CBCleanupProc,
    pub mutate: CBMutateProc,
    pub crossover: CBCrossoverProc,
    pub getState: CBGetStateProc,
    pub setState: CBSetStateProc,
    pub resetState: CBResetStateProc,
}
#[test]
fn bindgen_test_layout_CBlock() {
    assert_eq!(
        ::std::mem::size_of::<CBlock>(),
        176usize,
        concat!("Size of: ", stringify!(CBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<CBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(CBlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).inlineBlockId as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(inlineBlockId)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).owned as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(owned)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).help as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(help)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).setup as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).destroy as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(destroy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).inputTypes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(inputTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).outputTypes as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(outputTypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).exposedVariables as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(exposedVariables)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).requiredVariables as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(requiredVariables)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).compose as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(compose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).composed as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(composed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).parameters as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(parameters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).setParam as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(setParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).getParam as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(getParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).warmup as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(warmup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).activate as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(activate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).cleanup as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).mutate as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(mutate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).crossover as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(crossover)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).getState as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(getState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).setState as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(setState)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBlock>())).resetState as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CBlock),
            "::",
            stringify!(resetState)
        )
    );
}
impl Default for CBlock {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBChainProviderUpdate {
    pub error: *const ::std::os::raw::c_char,
    pub chain: *mut CBChain,
}
#[test]
fn bindgen_test_layout_CBChainProviderUpdate() {
    assert_eq!(
        ::std::mem::size_of::<CBChainProviderUpdate>(),
        16usize,
        concat!("Size of: ", stringify!(CBChainProviderUpdate))
    );
    assert_eq!(
        ::std::mem::align_of::<CBChainProviderUpdate>(),
        8usize,
        concat!("Alignment of ", stringify!(CBChainProviderUpdate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainProviderUpdate>())).error as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainProviderUpdate),
            "::",
            stringify!(error)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainProviderUpdate>())).chain as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainProviderUpdate),
            "::",
            stringify!(chain)
        )
    );
}
impl Default for CBChainProviderUpdate {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CBProviderReset =
    ::std::option::Option<unsafe extern "C" fn(provider: *mut CBChainProvider)>;
pub type CBProviderReady =
    ::std::option::Option<unsafe extern "C" fn(provider: *mut CBChainProvider) -> CBBool>;
pub type CBProviderSetup = ::std::option::Option<
    unsafe extern "C" fn(
        provider: *mut CBChainProvider,
        path: *const ::std::os::raw::c_char,
        data: CBInstanceData,
    ),
>;
pub type CBProviderUpdated =
    ::std::option::Option<unsafe extern "C" fn(provider: *mut CBChainProvider) -> CBBool>;
pub type CBProviderAcquire = ::std::option::Option<
    unsafe extern "C" fn(provider: *mut CBChainProvider) -> CBChainProviderUpdate,
>;
pub type CBProviderReleaseChain = ::std::option::Option<
    unsafe extern "C" fn(provider: *mut CBChainProvider, chain: *mut CBChain),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBChainProvider {
    pub reset: CBProviderReset,
    pub ready: CBProviderReady,
    pub setup: CBProviderSetup,
    pub updated: CBProviderUpdated,
    pub acquire: CBProviderAcquire,
    pub release: CBProviderReleaseChain,
    pub userData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_CBChainProvider() {
    assert_eq!(
        ::std::mem::size_of::<CBChainProvider>(),
        56usize,
        concat!("Size of: ", stringify!(CBChainProvider))
    );
    assert_eq!(
        ::std::mem::align_of::<CBChainProvider>(),
        8usize,
        concat!("Alignment of ", stringify!(CBChainProvider))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainProvider>())).reset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainProvider),
            "::",
            stringify!(reset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainProvider>())).ready as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainProvider),
            "::",
            stringify!(ready)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainProvider>())).setup as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainProvider),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainProvider>())).updated as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainProvider),
            "::",
            stringify!(updated)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainProvider>())).acquire as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainProvider),
            "::",
            stringify!(acquire)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainProvider>())).release as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainProvider),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainProvider>())).userData as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainProvider),
            "::",
            stringify!(userData)
        )
    );
}
impl Default for CBChainProvider {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CBValidationCallback = ::std::option::Option<
    unsafe extern "C" fn(
        errorBlock: *const CBlock,
        errorTxt: *const ::std::os::raw::c_char,
        nonfatalWarning: CBBool,
        userData: *mut ::std::os::raw::c_void,
    ),
>;
pub type CBRegisterBlock = ::std::option::Option<
    unsafe extern "C" fn(fullName: *const ::std::os::raw::c_char, constructor: CBBlockConstructor),
>;
pub type CBRegisterObjectType =
    ::std::option::Option<unsafe extern "C" fn(vendorId: i32, typeId: i32, info: CBObjectInfo)>;
pub type CBRegisterEnumType =
    ::std::option::Option<unsafe extern "C" fn(vendorId: i32, typeId: i32, info: CBEnumInfo)>;
pub type CBRegisterRunLoopCallback = ::std::option::Option<
    unsafe extern "C" fn(eventName: *const ::std::os::raw::c_char, callback: CBCallback),
>;
pub type CBRegisterExitCallback = ::std::option::Option<
    unsafe extern "C" fn(eventName: *const ::std::os::raw::c_char, callback: CBCallback),
>;
pub type CBUnregisterRunLoopCallback =
    ::std::option::Option<unsafe extern "C" fn(eventName: *const ::std::os::raw::c_char)>;
pub type CBUnregisterExitCallback =
    ::std::option::Option<unsafe extern "C" fn(eventName: *const ::std::os::raw::c_char)>;
pub type CBReferenceVariable = ::std::option::Option<
    unsafe extern "C" fn(
        context: *mut CBContext,
        name: *const ::std::os::raw::c_char,
    ) -> *mut CBVar,
>;
pub type CBReleaseVariable = ::std::option::Option<unsafe extern "C" fn(variable: *mut CBVar)>;
pub type CBThrowException =
    ::std::option::Option<unsafe extern "C" fn(errorText: *const ::std::os::raw::c_char)>;
pub type CBSuspend = ::std::option::Option<
    unsafe extern "C" fn(context: *mut CBContext, seconds: f64) -> CBChainState,
>;
pub type CBCloneVar =
    ::std::option::Option<unsafe extern "C" fn(dst: *mut CBVar, src: *const CBVar)>;
pub type CBDestroyVar = ::std::option::Option<unsafe extern "C" fn(var: *mut CBVar)>;
pub type CBValidateChain = ::std::option::Option<
    unsafe extern "C" fn(
        chain: *mut CBChain,
        callback: CBValidationCallback,
        userData: *mut ::std::os::raw::c_void,
        data: CBInstanceData,
    ) -> CBValidationResult,
>;
pub type CBRunChain = ::std::option::Option<
    unsafe extern "C" fn(
        chain: *mut CBChain,
        context: *mut CBContext,
        input: CBVar,
    ) -> CBRunChainOutput,
>;
pub type CBValidateSetParam = ::std::option::Option<
    unsafe extern "C" fn(
        block: *mut CBlock,
        index: ::std::os::raw::c_int,
        param: CBVar,
        callback: CBValidationCallback,
        userData: *mut ::std::os::raw::c_void,
    ) -> CBBool,
>;
pub type CBValidateBlocks = ::std::option::Option<
    unsafe extern "C" fn(
        blocks: CBlocks,
        callback: CBValidationCallback,
        userData: *mut ::std::os::raw::c_void,
        data: CBInstanceData,
    ) -> CBValidationResult,
>;
pub type CBRunBlocks = ::std::option::Option<
    unsafe extern "C" fn(
        blocks: CBlocks,
        context: *mut CBContext,
        input: CBVar,
        output: *mut CBVar,
        handleReturn: CBBool,
    ) -> CBChainState,
>;
pub type CBLog = ::std::option::Option<unsafe extern "C" fn(msg: *const ::std::os::raw::c_char)>;
pub type CBCreateBlock =
    ::std::option::Option<unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> *mut CBlock>;
pub type CBCreateChain = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        blocks: CBlocks,
        looped: CBBool,
        unsafe_: CBBool,
    ) -> CBChainRef,
>;
pub type CBDestroyChain = ::std::option::Option<unsafe extern "C" fn(chain: CBChainRef)>;
pub type CBCreateNode = ::std::option::Option<unsafe extern "C" fn() -> CBNodeRef>;
pub type CBDestroyNode = ::std::option::Option<unsafe extern "C" fn(node: CBNodeRef)>;
pub type CBSchedule =
    ::std::option::Option<unsafe extern "C" fn(node: CBNodeRef, chain: CBChainRef)>;
pub type CBTick = ::std::option::Option<unsafe extern "C" fn(node: CBNodeRef) -> CBBool>;
pub type CBSleep = ::std::option::Option<unsafe extern "C" fn(seconds: f64, runCallbacks: CBBool)>;
pub type CBSeqFree = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBSeq)>;
pub type CBSeqPush =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBSeq, arg2: *const CBVar)>;
pub type CBSeqInsert =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBSeq, arg2: u32, arg3: *const CBVar)>;
pub type CBSeqPop = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBSeq) -> CBVar>;
pub type CBSeqResize = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBSeq, arg2: u32)>;
pub type CBSeqFastDelete = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBSeq, arg2: u32)>;
pub type CBSeqSlowDelete = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBSeq, arg2: u32)>;
pub type CBTypesInfoFree = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBTypesInfo)>;
pub type CBTypesInfoPush =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBTypesInfo, arg2: *const CBTypeInfo)>;
pub type CBTypesInfoInsert = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBTypesInfo, arg2: u32, arg3: *const CBTypeInfo),
>;
pub type CBTypesInfoPop =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBTypesInfo) -> CBTypeInfo>;
pub type CBTypesInfoResize =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBTypesInfo, arg2: u32)>;
pub type CBTypesInfoFastDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBTypesInfo, arg2: u32)>;
pub type CBTypesInfoSlowDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBTypesInfo, arg2: u32)>;
pub type CBParametersInfoFree =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBParametersInfo)>;
pub type CBParametersInfoPush = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBParametersInfo, arg2: *const CBParameterInfo),
>;
pub type CBParametersInfoInsert = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBParametersInfo, arg2: u32, arg3: *const CBParameterInfo),
>;
pub type CBParametersInfoPop =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBParametersInfo) -> CBParameterInfo>;
pub type CBParametersInfoResize =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBParametersInfo, arg2: u32)>;
pub type CBParametersInfoFastDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBParametersInfo, arg2: u32)>;
pub type CBParametersInfoSlowDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBParametersInfo, arg2: u32)>;
pub type CBlocksFree = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlocks)>;
pub type CBlocksPush =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlocks, arg2: *const CBlockPtr)>;
pub type CBlocksInsert = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBlocks, arg2: u32, arg3: *const CBlockPtr),
>;
pub type CBlocksPop = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlocks) -> CBlockPtr>;
pub type CBlocksResize = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlocks, arg2: u32)>;
pub type CBlocksFastDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlocks, arg2: u32)>;
pub type CBlocksSlowDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBlocks, arg2: u32)>;
pub type CBExposedTypesInfoFree =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBExposedTypesInfo)>;
pub type CBExposedTypesInfoPush = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBExposedTypesInfo, arg2: *const CBExposedTypeInfo),
>;
pub type CBExposedTypesInfoInsert = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBExposedTypesInfo, arg2: u32, arg3: *const CBExposedTypeInfo),
>;
pub type CBExposedTypesInfoPop =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBExposedTypesInfo) -> CBExposedTypeInfo>;
pub type CBExposedTypesInfoResize =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBExposedTypesInfo, arg2: u32)>;
pub type CBExposedTypesInfoFastDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBExposedTypesInfo, arg2: u32)>;
pub type CBExposedTypesInfoSlowDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBExposedTypesInfo, arg2: u32)>;
pub type CBStringsFree = ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBStrings)>;
pub type CBStringsPush =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBStrings, arg2: *const CBString)>;
pub type CBStringsInsert = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut CBStrings, arg2: u32, arg3: *const CBString),
>;
pub type CBStringsPop =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBStrings) -> CBString>;
pub type CBStringsResize =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBStrings, arg2: u32)>;
pub type CBStringsFastDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBStrings, arg2: u32)>;
pub type CBStringsSlowDelete =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut CBStrings, arg2: u32)>;
pub type CBTableNew = ::std::option::Option<unsafe extern "C" fn() -> CBTable>;
pub type CBGetRootPath =
    ::std::option::Option<unsafe extern "C" fn() -> *const ::std::os::raw::c_char>;
pub type CBSetRootPath =
    ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CBChainInfo {
    pub name: *const ::std::os::raw::c_char,
    pub looped: bool,
    pub unsafe_: bool,
    pub chain: *const CBChain,
    pub blocks: CBlocks,
}
#[test]
fn bindgen_test_layout_CBChainInfo() {
    assert_eq!(
        ::std::mem::size_of::<CBChainInfo>(),
        40usize,
        concat!("Size of: ", stringify!(CBChainInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<CBChainInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(CBChainInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainInfo>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainInfo>())).looped as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainInfo),
            "::",
            stringify!(looped)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainInfo>())).unsafe_ as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainInfo),
            "::",
            stringify!(unsafe_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainInfo>())).chain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainInfo),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBChainInfo>())).blocks as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CBChainInfo),
            "::",
            stringify!(blocks)
        )
    );
}
impl Default for CBChainInfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type CBGetChainInfo =
    ::std::option::Option<unsafe extern "C" fn(chainref: CBChainRef) -> CBChainInfo>;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct CBCore {
    pub registerBlock: CBRegisterBlock,
    pub registerObjectType: CBRegisterObjectType,
    pub registerEnumType: CBRegisterEnumType,
    pub registerRunLoopCallback: CBRegisterRunLoopCallback,
    pub unregisterRunLoopCallback: CBUnregisterRunLoopCallback,
    pub registerExitCallback: CBRegisterExitCallback,
    pub unregisterExitCallback: CBUnregisterExitCallback,
    pub referenceVariable: CBReferenceVariable,
    pub releaseVariable: CBReleaseVariable,
    pub throwException: CBThrowException,
    pub throwActivationError: CBThrowException,
    pub suspend: CBSuspend,
    pub cloneVar: CBCloneVar,
    pub destroyVar: CBDestroyVar,
    pub seqFree: CBSeqFree,
    pub seqPush: CBSeqPush,
    pub seqInsert: CBSeqInsert,
    pub seqPop: CBSeqPop,
    pub seqResize: CBSeqResize,
    pub seqFastDelete: CBSeqFastDelete,
    pub seqSlowDelete: CBSeqSlowDelete,
    pub typesFree: CBTypesInfoFree,
    pub typesPush: CBTypesInfoPush,
    pub typesInsert: CBTypesInfoInsert,
    pub typesPop: CBTypesInfoPop,
    pub typesResize: CBTypesInfoResize,
    pub typesFastDelete: CBTypesInfoFastDelete,
    pub typesSlowDelete: CBTypesInfoSlowDelete,
    pub paramsFree: CBParametersInfoFree,
    pub paramsPush: CBParametersInfoPush,
    pub paramsInsert: CBParametersInfoInsert,
    pub paramsPop: CBParametersInfoPop,
    pub paramsResize: CBParametersInfoResize,
    pub paramsFastDelete: CBParametersInfoFastDelete,
    pub paramsSlowDelete: CBParametersInfoSlowDelete,
    pub blocksFree: CBlocksFree,
    pub blocksPush: CBlocksPush,
    pub blocksInsert: CBlocksInsert,
    pub blocksPop: CBlocksPop,
    pub blocksResize: CBlocksResize,
    pub blocksFastDelete: CBlocksFastDelete,
    pub blocksSlowDelete: CBlocksSlowDelete,
    pub expTypesFree: CBExposedTypesInfoFree,
    pub expTypesPush: CBExposedTypesInfoPush,
    pub expTypesInsert: CBExposedTypesInfoInsert,
    pub expTypesPop: CBExposedTypesInfoPop,
    pub expTypesResize: CBExposedTypesInfoResize,
    pub expTypesFastDelete: CBExposedTypesInfoFastDelete,
    pub expTypesSlowDelete: CBExposedTypesInfoSlowDelete,
    pub stringsFree: CBStringsFree,
    pub stringsPush: CBStringsPush,
    pub stringsInsert: CBStringsInsert,
    pub stringsPop: CBStringsPop,
    pub stringsResize: CBStringsResize,
    pub stringsFastDelete: CBStringsFastDelete,
    pub stringsSlowDelete: CBStringsSlowDelete,
    pub tableNew: CBTableNew,
    pub validateChain: CBValidateChain,
    pub runChain: CBRunChain,
    pub validateBlocks: CBValidateBlocks,
    pub runBlocks: CBRunBlocks,
    pub getChainInfo: CBGetChainInfo,
    pub log: CBLog,
    pub createBlock: CBCreateBlock,
    pub validateSetParam: CBValidateSetParam,
    pub createChain: CBCreateChain,
    pub destroyChain: CBDestroyChain,
    pub createNode: CBCreateNode,
    pub destroyNode: CBDestroyNode,
    pub schedule: CBSchedule,
    pub tick: CBTick,
    pub sleep: CBSleep,
    pub getRootPath: CBGetRootPath,
    pub setRootPath: CBSetRootPath,
}
#[test]
fn bindgen_test_layout_CBCore() {
    assert_eq!(
        ::std::mem::size_of::<CBCore>(),
        592usize,
        concat!("Size of: ", stringify!(CBCore))
    );
    assert_eq!(
        ::std::mem::align_of::<CBCore>(),
        8usize,
        concat!("Alignment of ", stringify!(CBCore))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).registerBlock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(registerBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).registerObjectType as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(registerObjectType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).registerEnumType as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(registerEnumType)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).registerRunLoopCallback as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(registerRunLoopCallback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<CBCore>())).unregisterRunLoopCallback as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(unregisterRunLoopCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).registerExitCallback as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(registerExitCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).unregisterExitCallback as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(unregisterExitCallback)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).referenceVariable as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(referenceVariable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).releaseVariable as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(releaseVariable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).throwException as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(throwException)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).throwActivationError as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(throwActivationError)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).suspend as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).cloneVar as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(cloneVar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).destroyVar as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(destroyVar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).seqFree as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(seqFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).seqPush as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(seqPush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).seqInsert as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(seqInsert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).seqPop as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(seqPop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).seqResize as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(seqResize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).seqFastDelete as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(seqFastDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).seqSlowDelete as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(seqSlowDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).typesFree as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(typesFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).typesPush as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(typesPush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).typesInsert as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(typesInsert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).typesPop as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(typesPop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).typesResize as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(typesResize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).typesFastDelete as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(typesFastDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).typesSlowDelete as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(typesSlowDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).paramsFree as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(paramsFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).paramsPush as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(paramsPush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).paramsInsert as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(paramsInsert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).paramsPop as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(paramsPop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).paramsResize as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(paramsResize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).paramsFastDelete as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(paramsFastDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).paramsSlowDelete as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(paramsSlowDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).blocksFree as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(blocksFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).blocksPush as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(blocksPush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).blocksInsert as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(blocksInsert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).blocksPop as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(blocksPop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).blocksResize as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(blocksResize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).blocksFastDelete as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(blocksFastDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).blocksSlowDelete as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(blocksSlowDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).expTypesFree as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(expTypesFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).expTypesPush as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(expTypesPush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).expTypesInsert as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(expTypesInsert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).expTypesPop as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(expTypesPop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).expTypesResize as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(expTypesResize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).expTypesFastDelete as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(expTypesFastDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).expTypesSlowDelete as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(expTypesSlowDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).stringsFree as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(stringsFree)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).stringsPush as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(stringsPush)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).stringsInsert as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(stringsInsert)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).stringsPop as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(stringsPop)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).stringsResize as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(stringsResize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).stringsFastDelete as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(stringsFastDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).stringsSlowDelete as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(stringsSlowDelete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).tableNew as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(tableNew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).validateChain as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(validateChain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).runChain as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(runChain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).validateBlocks as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(validateBlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).runBlocks as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(runBlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).getChainInfo as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(getChainInfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).log as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).createBlock as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(createBlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).validateSetParam as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(validateSetParam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).createChain as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(createChain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).destroyChain as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(destroyChain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).createNode as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(createNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).destroyNode as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(destroyNode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).schedule as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(schedule)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).tick as *const _ as usize },
        560usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).sleep as *const _ as usize },
        568usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(sleep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).getRootPath as *const _ as usize },
        576usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(getRootPath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CBCore>())).setRootPath as *const _ as usize },
        584usize,
        concat!(
            "Offset of field: ",
            stringify!(CBCore),
            "::",
            stringify!(setRootPath)
        )
    );
}
pub type CBChainblocksInterface =
    ::std::option::Option<unsafe extern "C" fn(abi_version: u32, core: *mut CBCore) -> CBBool>;
extern "C" {
    pub fn chainblocksInterface(abi_version: u32, core: *mut CBCore) -> CBBool;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct lconv {
    pub _address: u8,
}
