(def timestep (/ 1.0 120.0))
(defmesh root)

(defshards spin-transform [t location]
  t
  (| (Math.Multiply 0.2) (Math.AxisAngleX) (Math.Rotation) >= .rotX)
  (| (Math.Multiply 0.7) (Math.AxisAngleY) (Math.Rotation) >= .rotY)
  (| (Math.Multiply 0.9) (Math.AxisAngleZ) (Math.Rotation) >= .rotZ)
  location (Math.Translation) (Math.MatMul .rotX) (Math.MatMul .rotY) (Math.MatMul .rotZ))

(defn make-inner-wire [id base-color]
  (Wire id :Looped
        (Setup
         0.0 >= .time
         "<text>" >= .text1

         (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) >= .mesh

         (GFX.DrawQueue) >= .queue
         (GFX.DrawQueue) >= .ui-queue

         (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .features1
         (GFX.BuiltinFeature  BuiltinFeatureId.BaseColor) >> .features1
         (GFX.UIPass :Queue .ui-queue) >> .render-steps1
         (GFX.DrawablePass :Features .features1 :Queue .queue) >> .render-steps1

         ;; Create view
         {:Position (Float3 0 0 8) :Target (Float3 0 0 0)} (Math.LookAt) >= .view-transform
         (GFX.View :View .view-transform) >= .view)

        .view-transform (FreeCamera) > .view-transform

        .time (Math.Add timestep) > .time

        (spin-transform .time (Float3 -0.6 0 0))
        (GFX.Drawable :Mesh .mesh :Params {:baseColor base-color}) (GFX.Draw .queue)

        (UI .ui-queue
            (-> ; UI Content
             (UI.Window
              :Contents
              (->
               "This is UI inside a render target" (UI.Label)
               (UI.TextField :Variable .text1 :Multiline true)
               ;
               ))))

        ; This renders to the render target that was pushed in the outer wire
        (GFX.Render :Steps .render-steps1 :View .view)))

(def inner-wire-0 (make-inner-wire "inner-0" (Float4 1 0 1 1)))
(def inner-wire-1 (make-inner-wire "inner-1" (Float4 0 1 0 1)))

(defshards compute-rt-region-16-9 []
  (| (Take [0 1]) >= .min)
  (| (Take [0]) >= .min-x)
  (| (Take [1]) >= .min-y)
  (| (Take [2 3]) (Math.Subtract .min) >= .size)
  .size (Take [0]) >= .size-x (Math.Multiply (/ 9.0 16.0)) >= .size-y

  .size-x (Math.Add .min-x) >= .max-x
  .size-y (Math.Add .min-y) >= .max-y
  [.min-x .min-y .max-x .max-y] (ToFloat4))

(defloop test-wire
  (Setup
   ; UI Setup
   (GFX.DrawQueue) >= .ui-draw-queue
   (GFX.UIPass .ui-draw-queue) >> .render-steps

   "Something" >= .text)

  (GFX.MainWindow
   :Title "SDL Window" :Width 1280 :Height 720 
   :Contents
   (->
    (GFX.Texture :Format TextureFormat.RGBA8UnormSrgb) >= .rt-0
    (GFX.Texture :Format TextureFormat.RGBA8UnormSrgb) >= .rt-1

    (UI .ui-draw-queue
        (-> ; UI Content
         (UI.Window
          :Contents
          (->
           (UI.GetProperty UIProperty.RemainingSpace) >= .rt-region
           (compute-rt-region-16-9) > .rt-region

           (GFX.RenderInto :Textures {:color .rt-0} :WindowRegion .rt-region :Contents (Step inner-wire-0))
           .rt-0 (UI.RenderTarget)

           (UI.Separator)
           (UI.TextField :Variable .text :Multiline true)))

         (UI.Window
          :Title "Second Window"
          :Contents
          (->
           "Header" (UI.Label) (UI.Separator)

           (UI.GetProperty UIProperty.RemainingSpace) >= .rt-region
           (compute-rt-region-16-9) > .rt-region

           (GFX.RenderInto :Textures {:color .rt-1} :WindowRegion .rt-region :Contents (Step inner-wire-1))
           .rt-1 (UI.RenderTarget)

           (UI.Separator) "Footer" (UI.Label)))))

    (GFX.Render :Steps .render-steps))))

(schedule root test-wire)
(if (run root timestep 100) nil (throw "Root tick failed"))
