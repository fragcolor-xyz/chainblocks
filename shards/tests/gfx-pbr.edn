(load-file "gfx-lib/lib.edn")
(load-file "gfx-lib/atmosphere.edn")
(load-file "gfx-lib/pbr.edn")
(setup-pbr-lib (slurp "gfx-lib/pbr.wgsl") filter-cubemap render-cubemap-0)

(def timestep (/ 1.0 120.0))
(def pi 3.14159265359)
(def pi2 (* pi 2.0))
(defmesh Root)

(defshards sky-sphere-fs []
  ; Just sample the cubemap
  (Shader.ReadInput "texCoord0") >= .uv
  .uv (Shader.SampleTextureCoord "sky")
  (Shader.WriteOutput "color")

  ; NOTE: Write depth to compare to (>=) and render sky where it passes
  1.0 (Shader.WriteOutput "depth"))

(defshards sphere-map-pass [texture]
  (Setup
   (GFX.BuiltinFeature :Id BuiltinFeatureId.Transform) >> .sky-sphere-features
   (GFX.Feature
    :Params {:sky texture}
    :Shaders [{:Stage ProgrammableGraphicsStage.Vertex
               :EntryPoint (sky-sphere-vs)
               :After ["initScreenPosition"]
               :Before ["writePosition"]}
              {:Stage ProgrammableGraphicsStage.Fragment
               :EntryPoint (sky-sphere-fs)}]
    :State {:FlipFrontFace true :DepthWrite false :DepthCompare CompareFunction.LessEqual}) >> .sky-sphere-features
   (render-sky-sphere-queue "sky-sphere-queue" {}))
  (GFX.DrawablePass :Features .sky-sphere-features :Queue .sky-sphere-queue))

(defloop test-wire
  :Looped
  (GFX.MainWindow
   :Title "SDL Window" :Width 1280 :Height 720
   :Contents (->
              (Setup
               (LoadImage "data/footprint_court.hdr") (GFX.Texture) = .sphere-map-texture)
              (sphere-map-pass .sphere-map-texture) = .skybox-step
              .skybox-step >> .render-steps
              (GFX.DrawQueue) = .queue

              (Animation.Timer :Rate 0.2) = .t

              5.0 = .r
              .t (Math.Cos) (Math.Multiply .r) >= .x
              .t (Math.Sin) (Math.Multiply .r) >= .z
              .t (Math.Multiply 0.4) (Math.Sin) (Math.Multiply 2.0) >= .y

              ; Rotating camera
              {:Target (Float3 0.0 0.0 0.0) :Position (Float3 0.0)} >= .lookat
              (Float3 .x .y .z) (Update .lookat "Position")
              .lookat (Math.LookAt) >= .view-transform

              ; Static Camera
              ;; {:Target (Float3 0.0) :Position (Float3 0.0 0.0 5.5)} (Math.LookAt) >= .view-transform

              90.0 (Math.DegreesToRadians) (Math.AxisAngleX) (Math.Rotation) = .rot-z
              (Float3 0 0 0) (Math.Translation) = .tsl
              .tsl (Math.MatMul .rot-z)
              (GFX.glTF :Path "../../external/glTF-Sample-Models/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb") (GFX.Draw .queue)

              ;; (Math.MatIdentity)
              ;; (GFX.glTF :Path "../../external/glTF-Sample-Models/2.0/NormalTangentTest/glTF-Binary/NormalTangentTest.glb") (GFX.Draw .queue)

              (GFX.View .view-transform) = .view

              (Setup
               (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .capture-features
               (GFX.BuiltinFeature BuiltinFeatureId.BaseColor) >> .capture-features

               .skybox-step >> .capture-steps)

              ;; Main features & render step
              (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .features
              (GFX.BuiltinFeature BuiltinFeatureId.BaseColor) >> .features
              (render-pbr-base .capture-steps) >> .features ; Create/update PBR render step here
              (GFX.DrawablePass :Queue .queue :Features .features) >> .steps
              .skybox-step >> .steps

              (GFX.Render .steps .view))))

(schedule Root test-wire)
(if (run Root timestep) nil (throw "Root tick failed"))
