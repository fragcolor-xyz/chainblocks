@define(has-models false IgnoreRedefined: true)

@mesh(main)

@wire(ml-test {
  [1.0 2.0 3.0 4.0 5.0 6.0] | Tensor(Shape: [2 3] Type: TensorType::F32)
  {Tensor.ToString | Log}
  Tensor.Transpose
  {Tensor.ToString | Log}
  Tensor.Sum
  {Tensor.ToString | Log}

  [2 2 2] = shape
  Maybe({; this one will fail
    [1.0 2.0 3.0 4.0 5.0 6.0]
    Tensor(Shape: shape Type: TensorType::F32) | Tensor.ToString | Log
  })
  [1.0 2.0 3.0 4.0 5.0 6.0 7.0 8.0]
  Tensor(Shape: shape Type: TensorType::F32) | Tensor.ToString | Log

  When({@has-models | Is("true")} {
    ; "data/gte-tiny-tokenizer.json"
    "data/GIST-all-MiniLM-L6-v2-tokenizer.json"
    FS.Read | ML.Tokenizer = tokenizer
    "This is a test." | ML.Tokens(Tokenizer: tokenizer) | Log
    "This is a test." | ML.Tokens(Tokenizer: tokenizer AsTensor: true) | Tensor.ToString | Log

    ; "data/gte-tiny-config.json"
    "data/GIST-all-MiniLM-L6-v2-config.json"
    FS.Read | FromJson | ExpectTable = config | Log
    ; "data/gte-tiny.safetensors"
    "data/GIST-all-MiniLM-L6-v2.safetensors"
    FS.Read(Bytes: true)
    ML.Model(Model: MLModels::Bert Format: MLFormats::SafeTensor Configuration: config) = bert-model

    Repeat({
      "I love pasta" | ML.Tokens(tokenizer AsTensor: true Format: TensorType::I64) = test1-tokens
      Tensor.ZerosLike = test1-zeros | Tensor.Shape | RTake(1) | ToFloat = num-tokens1
      [test1-tokens test1-zeros] | ML.Forward(Model: bert-model) | Take(0)
      Tensor.Sum([1]) | Tensor.Div(num-tokens1) = emb-i

      "Do you like pizza?" | ML.Tokens(tokenizer AsTensor: true Format: TensorType::I64) = test2-tokens
      Tensor.ZerosLike = test2-zeros | Tensor.Shape | RTake(1) | ToFloat = num-tokens2
      [test2-tokens test2-zeros] | ML.Forward(Model: bert-model) | Take(0)
      Tensor.Sum([1]) | Tensor.Div(num-tokens2) = emb-j

      ; cosine similarity
      emb-i | Tensor.Mul(emb-j) | Tensor.Sum | Tensor.ToFloat = sum-ij
      emb-i | Tensor.Mul(emb-i) | Tensor.Sum | Tensor.ToFloat = sum-i2
      emb-j | Tensor.Mul(emb-j) | Tensor.Sum | Tensor.ToFloat = sum-j2
      sum-i2 | Mul(sum-j2) | Sqrt = sqrt-ij
      sum-ij | Div(sqrt-ij) = cosine-similarity | Log
    } Times: 10)
  })
})

@schedule(main ml-test)
@run(main) | Assert.Is(true)
