(def timestep (/ 1.0 120.0))
(defmesh root)

(defshards base []
  (Setup
   (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) >= .mesh

   (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .features
   (GFX.BuiltinFeature BuiltinFeatureId.BaseColor) >> .features
   (GFX.DrawQueue) >= .queue
   (GFX.DrawablePass :Features .features :Queue .queue) >> .render-steps

   (GFX.Texture :Format TextureFormat.R16Uint) >= .u8-tex
   (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .features-1
   (GFX.Feature :State {:DepthCompare CompareFunction.Equal :DepthWrite false}
                :Params {:index 0}
                :Shaders
                [{:Stage ProgrammableGraphicsStage.Fragment
                  :EntryPoint
                  (->
                   ; Write to index output
                   (Shader.ReadBuffer "index")
                   (Shader.WriteOutput "index"))}]) >> .features-1

   ; Second pass to render to index texture
   (GFX.DrawablePass :Features .features-1
                     :Outputs [{:Name "index" :Texture .u8-tex}
                               {:Name "depth"}]
                     :Queue .queue) >> .render-steps

   {:Position (Float3 0 1 8) :Target (Float3 0 0 0)} (Math.LookAt) >= .view-transform


   (GFX.View :View .view-transform) >= .view))

(defloop test-copy-async
  (base)
  (GFX.MainWindow
   :Title "SDL Window" :Width 1280 :Height 720
   :UseDisplayScaling false
   :Contents
   (->
    (Setup 0 >= .frame-index)

    (Float3 -1.0 0.0 0.0) (Math.Translation)
    (GFX.Drawable :Mesh .mesh :Params {:index .frame-index}) (GFX.Draw .queue)
    (Float3 1.0 0.0 0.0) (Math.Translation)
    (GFX.Drawable :Mesh .mesh :Params {:index 0xffff}) (GFX.Draw .queue)

    (GFX.Render :Steps .render-steps :View .view)

    ;; This end frame is required when using `:Wait true` with the ReadTexture shard,
    ;;  since rendering command buffers are queued in EndFrame
    ;;  and texture copy needs to happen afterwards
    ;; (GFX.EndFrame)

    .u8-tex (GFX.ReadTexture) = .image
    .frame-index (Log "This frame index")
    (Int2 400 400) (GetImagePixel .image :AsInteger true :Default (Int4 0)) = .p0 (Log "Pixel (400, 400)")
    (Int2 800 400) (GetImagePixel .image :AsInteger true :Default (Int4 0)) = .p1 (Log "Pixel (800, 400)")

    ; With a frame delay, check that the values match the expected ones
    .frame-index (When (IsMore 0)
                       (->
                        .p0:0 = .p0-x
                        .p1:0 = .p1-x
                        .frame-index (Math.Subtract 1) = .expected-frame-index
                        .p0-x (Assert.Is .expected-frame-index)
                        .p1-x (Assert.Is 0xffff)))

    (Math.Inc .frame-index))))

(defloop test-copy-sync
  (base)
  ;; Sync test
  (GFX.MainWindow
   :Title "SDL Window" :Width 1280 :Height 720
   :UseDisplayScaling false
   :Contents
   (->
    (Float3 -1.0 0.0 0.0) (Math.Translation)
    (GFX.Drawable :Mesh .mesh :Params {:index 0xffff}) (GFX.Draw .queue)

    (GFX.Render :Steps .render-steps :View .view)

    ;; This end frame is required when using `:Wait true` with the ReadTexture shard,
    ;;  since rendering command buffers are queued in EndFrame
    ;;  and texture copy needs to happen afterwards
    (GFX.EndFrame)

    .u8-tex (GFX.ReadTexture :Wait true) = .image
    (Int2 400 400) (GetImagePixel .image :AsInteger true :Default (Int4 0)) = .p0 (Log "Pixel (400, 400)")
    .p0 (Assert.Is (Int4 0xffff 0 0 0)))))

(schedule root test-copy-async)
(if (run root timestep 32) nil (throw "Root tick failed"))

(schedule root test-copy-sync)
(if (run root timestep 32) nil (throw "Root tick failed"))
