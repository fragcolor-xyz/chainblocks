@define(timestep #(1.0 | Math.Divide(120.0)))
@mesh(root)

@template(spin-transform [t location] {
  t |
  {Math.Multiply(0.2) | Math.AxisAngleX | Math.Rotation >= rotX} |
  {Math.Multiply(0.7) | Math.AxisAngleY | Math.Rotation >= rotY} |
  {Math.Multiply(0.9) | Math.AxisAngleZ | Math.Rotation >= rotZ}
  location | Math.Translation | Math.MatMul(rotX) | Math.MatMul(rotY) | Math.MatMul(rotZ)
})

@wire(test-wire {
  Once({
    GFX.BuiltinMesh(Type: BuiltinMeshType::Cube) >= cube-mesh
    GFX.DrawQueue >= queue

    GFX.BuiltinFeature(BuiltinFeatureId::Transform) >> features
    GFX.BuiltinFeature(BuiltinFeatureId::BaseColor) >> features
    GFX.DrawablePass(Features: features Queue: queue) >> render-steps

    ; UI Setup
    GFX.DrawQueue >= ui-draw-queue
    GFX.UIPass(ui-draw-queue) >> render-steps

    ; Create view
    {Position: @f3(0 0 20) Target: @f3(0 0 0)} | Math.LookAt >= view-transform
    GFX.View(View: view-transform) >= view
  })

  ; Poll inputs
  GFX.MainWindow(
    Title: "SDL Window" Width: 1280 Height: 720
    DetachRenderer: true
  ) = window-ctx

  ; Input test code
  Inputs.Detached(window-ctx {
    false >= down
    Inputs.KeyDown("W" Action: {
      true > down
      Log("W Key down")
    })
    down
  } {
    When(Is(true) {
      Log("W Key down main thread")
    })
  } Name: "Camera" Priority: 1)

  ; Debug UI & Graphics
  GFX.Renderer(
    Window: window-ctx
    Contents: {
      Animation.Timer >= time

      @f4(0 1 0 1) >= color
      @spin-transform(time @f3(0 0 0))
      GFX.Drawable(Mesh: cube-mesh Params: {baseColor: color}) | GFX.Draw(queue)

      ; Inputs.Detached(
      ;   window-ctx Name: "UI" Priority: 10
      ;   Contents: {
      ;     UI(ui-draw-queue {
      ;       Inputs.DebugUI
      ;     })
      ;   }
      ; )

      GFX.Render(View: view Steps: render-steps)
    }
  )
} Looped: true)

@schedule(root test-wire)
@run(root FPS: 120 Iterations: 100) | Assert.Is(true)
