; SPDX-License-Identifier: BSD-3-Clause
; Copyright Â© 2022 Fragcolor Pte. Ltd.

;; Notes:
;;   This file contains unit tests for the UI shards.
;;   It is not meant to be realistic. For such samples, look at egui-demo.edn.

(defmesh main)
(def timestep (/ 1.0 60.0))
(def duration 60)
(def input "**input**")

;; label
(defloop label-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)
    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        "Hello Shards!" (UI.Label)
        (Assert.Is "Hello Shards!" :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main label-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; listbox
(defloop listbox-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)
    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        ["Hello" "World"] (UI.ListBox .index) (ExpectString)
        .index (ExpectInt)))))

    (GFX.Render :Steps .render-steps))))
(schedule main listbox-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; numeric input
(defloop numeric-input-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)
    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        (UI.IntInput) (ExpectInt)
        (UI.Int2Input) (ExpectInt2)
        (UI.Int3Input) (ExpectInt3)
        (UI.Int4Input) (ExpectInt4)
        (UI.FloatInput) (ExpectFloat)
        (UI.Float2Input) (ExpectFloat2)
        (UI.Float3Input) (ExpectFloat3)
        (UI.Float4Input) (ExpectFloat4)))))

    (GFX.Render :Steps .render-steps))))
(schedule main numeric-input-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; numeric slider
(defloop numeric-slider-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)
    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        (UI.IntSlider :Min 1 :Max 100) (ExpectInt)
        (UI.Int2Slider :Min (int2 1) :Max (int2 100)) (ExpectInt2)
        (UI.Int3Slider :Min (int3 1) :Max (int3 100)) (ExpectInt3)
        (UI.Int4Slider :Min (int4 1) :Max (int4 100)) (ExpectInt4)
        (UI.FloatSlider :Min 0.0 :Max 1.0) (ExpectFloat)
        (UI.Float2Slider :Min (float2 0) :Max (float2 1)) (ExpectFloat2)
        (UI.Float3Slider :Min (float3 0) :Max (float3 1)) (ExpectFloat3)
        (UI.Float4Slider :Min (float4 0) :Max (float4 1)) (ExpectFloat4)))))

    (GFX.Render :Steps .render-steps))))
(schedule main numeric-slider-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; progress bar
(defloop progress-bar-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)
    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        (Setup 0.1 >= .progress)
        .progress
        (UI.ProgressBar)
        (ExpectFloat)
        (Math.Add 0.01) > .progress))))

    (GFX.Render :Steps .render-steps))))
(schedule main progress-bar-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; radio button
(defloop radio-button-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)
    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        (UI.RadioButton "Choice 1" .choice 1) (ExpectBool)
        (UI.RadioButton "Choice 2" .choice 2) (ExpectBool)
        (UI.RadioButton "Choice 3" .choice 3) (ExpectBool)
        .choice (ExpectInt)))))

    (GFX.Render :Steps .render-steps))))
(schedule main radio-button-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; spinner
(defloop spinner-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)
    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Spinner)
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main spinner-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; text input
(defloop text-input-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)
    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        (Setup "Lorem ipsum dolor sit amet" >= .text)
        (UI.TextField "read-only") (ExpectNone)
        (UI.TextField .text) (Maybe (ExpectNone) :Else (ExpectString))))))

    (GFX.Render :Steps .render-steps))))
(schedule main text-input-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; tooltip
(defloop tooltip-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)
    input
    (UI
     .ui-draw-queue
     (UI.CentralPanel
      :Contents
      (->
       (UI.Tooltip
        :Contents
        (->
         ;; input pass into
         (Assert.Is input :Break true)
         "Lorem ipsum" (UI.Label))
        :OnHover
        (->
         ;; input pass into
         (Assert.Is input :Break true)
         "Tooltip" (UI.Label)))
       ;; input passthrough
       (Assert.Is input :Break true))))
    ;; input passthrough
    (Assert.Is input :Break true)

    (GFX.Render :Steps .render-steps))))
(schedule main tooltip-test)
(if (run main timestep duration) nil (throw "Root tick failed"))
