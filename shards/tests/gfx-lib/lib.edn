; NOTE: Because of our coordinate space with the camera viewing -Z direction
;       The Y rotation for the Z axis is revesed
(def cube-rotations [(Float3 0 -90.0 0) ; X+
                     (Float3 0 90.0 0) ; X-
                     (Float3 90.0 180 0) ; Y+
                     (Float3 -90.0 180 0) ; Y-
                     (Float3 0 180 0) ; Z-
                     (Float3 0 0 0) ; Z+
                     ])

(defshards xyz-to-mat []
  (| (Take 0) >= .x) (| (Take 1) >= .y) (| (Take 2) >= .z)
  .x (Math.DegreesToRadians) (Math.AxisAngleX) (Math.Rotation) >= .rx
  .y (Math.DegreesToRadians) (Math.AxisAngleY) (Math.Rotation) >= .ry
  .z (Math.DegreesToRadians) (Math.AxisAngleZ) (Math.Rotation) >= .rz
  .rz (Math.MatMul .ry) (Math.MatMul .rx))

; {:steps [] :texture :mip-level :offset}
(defshards render-cubemap [probe-inner-steps cube-tex probe-offset mip-level]
  90.0 (Math.DegreesToRadians) >= .fov-10
  (map
   (fn* [n] (->
             cube-rotations (Take n)
             (xyz-to-mat) >= .tmp-rot
             probe-offset (Math.Translation) >= .tmp-tsl
             (Float3 -1 1 1) (Math.Scaling) >= .tmp-flip
             .tmp-tsl (Math.MatMul .tmp-rot) (Math.MatMul .tmp-flip) (Math.Inverse) >= (ContextVar (str "view-transform-" n))
             (GFX.View :View (ContextVar (str "view-transform-" n)) :Fov .fov-10) >= (ContextVar (str "capture-view-" n))
             (GFX.RenderInto :Textures {:color {:Texture cube-tex :Face n :Mip mip-level}}
                             :Contents (->
                                        (GFX.Render :Steps probe-inner-steps :View (ContextVar (str "capture-view-" n)))));
             ))
   (range 0 5));
  )

; {:steps [] :texture :offset}
(defshards render-cubemap-0 [probe-inner-steps cube-tex probe-offset]
  (render-cubemap probe-inner-steps cube-tex probe-offset 0))

(defshards sky-sphere-vs []
  (Shader.ReadGlobal "localPosition") (ToFloat3) (Math.Multiply 20.0)  >= .local-pos

  (Shader.ReadBuffer "view" :BufferName "view") >= .view
  (Shader.ReadBuffer "proj" :BufferName "view") >= .proj
  .local-pos (ToFloat4) >= .local-pos-4
  .view (Math.MatMul .local-pos-4) (Math.Add (Float4 0 0 0 1)) >= .view-pos-4
  .proj (Math.MatMul .view-pos-4) >= .screen-pos

  .screen-pos (Shader.WriteGlobal "screenPosition"))

(defshards render-sky-sphere-queue [id params]
  (Setup
   (GFX.DrawQueue :AutoClear false) = (ContextVar (str id))
   (GFX.BuiltinMesh :Type BuiltinMeshType.Sphere) >= (ContextVar (str id "-mesh")))

  params = (ContextVar (str id "-params"))
  (ContextVar (str id)) (GFX.ClearQueue)
  (Math.MatIdentity)
  (GFX.Drawable
   :Mesh (ContextVar (str id "-mesh"))
   :Params (ContextVar (str id "-params")))
  (GFX.Draw (ContextVar (str id))))

; Renders a screen space sphere into a cubemap
; this can be used for applying effects on cubemaps
(defshards filter-cubemap [effect-feature out-texture mip-level shader-params]
  (GFX.BuiltinFeature :Id BuiltinFeatureId.Transform) >> .filter-cubemap-features
  (GFX.Feature :State {:FlipFrontFace true :DepthWrite false}
               :Shaders [{:Stage ProgrammableGraphicsStage.Vertex
                          :EntryPoint (sky-sphere-vs)
                          :After ["initScreenPosition"]
                          :Before ["writePosition"]}]) >> .filter-cubemap-features
  effect-feature >> .filter-cubemap-features
  (render-sky-sphere-queue "filter-cubemap-queue" shader-params)
  (GFX.DrawablePass :Features .filter-cubemap-features :Queue .filter-cubemap-queue) >> .filter-cubemap-steps
  (render-cubemap .filter-cubemap-steps out-texture (Float3 0.0) mip-level))

;; (defshards sphere-map-fs []
;;   (Shader.ReadInput "texCoord0") = .coord
;;   .coord:0 = .u
;;   .coord:1 = .v
;;   (Float4 .u .v 0 1) (Shader.WriteGlobal "color"))

;; (defshards capture-probe [probe-inner-steps probe-offset resolution]
;;   (GFX.Texture :Format TextureFormat.RGBA8UnormSrgb :Resolution resolution :Dimension TextureDimension.Cube) >= .cube-tex
;;   {:steps probe-inner-steps :texture .cube-tex :offset probe-offset}
;;   (render-cubemap-0 probe-inner-steps .cube-tex probe-offset))
