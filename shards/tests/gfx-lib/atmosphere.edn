(defshards precompute-sky-fs []
  (Shader.Literal :Type ShaderLiteralType.Header :Source .atmosphere-wgsl)
  (Shader.ReadInput "worldNormal") (Math.Normalize) >= .ray-dir
  (Float3 0) >= .ray-start
  9999999999999.0 >= .ray-length

  .lightDir >= .light-dir
  .lightColor >= .light-color

  (Shader.Literal ["
  let _DrawPlanet = 0;
  if (_DrawPlanet == 1) {
    let planetIntersection = PlanetIntersection(" .ray-start ", " .ray-dir ");
    if (planetIntersection.x > 0.0) { " .ray-length " = min (" .ray-length ", planetIntersection.x); }
  }"])

  (Shader.Literal "var transmittance : vec3<f32> = vec3<f32>(0.0);")
  (Shader.Literal ["IntegrateScattering(" .ray-start ", " .ray-dir ", " .ray-length ", " .light-dir ", " .light-color ", &transmittance)"] :OutputDimension 3)
  (ToFloat4) (Math.Add (Float4 0 0 0 1))
  (Shader.WriteOutput "color"))

(defshards sky-fs []
  ; Just sample the cubemap
  (Shader.ReadInput "worldNormal") >= .world-normal
  (Shader.SampleTextureCoord "sky")
  (Shader.WriteOutput "color")

  ; NOTE: Write depth to compare to (>=) and render sky where it passes
  1.0 (Shader.WriteOutput "depth"))

(defshards precompute-sky [atmosphere-wgsl filter-cubemap]
  (Setup (bytes "") >= .last-param-hash
         (GFX.Texture :Format TextureFormat.RGBA8UnormSrgb :Resolution (Int2 1024) :Dimension TextureDimension.Cube) >= .sky-cube-tex)

  {:lightDir .light-direction
   :lightColor .light-color} = .param
  .param (ToBytes) (Hash.XXH-64) = .param-hash

  ; Hashed activation of cubemap precomputation
  .param-hash
  (When
   (IsNot .last-param-hash)
   (-> > .last-param-hash
       (Log "Recomputing skybox")
       (GFX.Feature :ComposeWith {:atmosphere-wgsl atmosphere-wgsl
                                  :lightDir .light-direction
                                  :lightColor .light-color}
                    :Shaders [{:Stage ProgrammableGraphicsStage.Fragment
                               :EntryPoint (precompute-sky-fs)}]) >= .filter-feature

       {} (filter-cubemap .filter-feature .sky-cube-tex 0 {})))
  {:sky .sky-cube-tex})

(defshards sky-sphere-vs []
  (Shader.ReadGlobal "localPosition") (ToFloat3) (Math.Multiply 20.0)  >= .local-pos

  (Shader.ReadBuffer "view" :BufferName "view") >= .view
  (Shader.ReadBuffer "proj" :BufferName "view") >= .proj
  .local-pos (ToFloat4) >= .local-pos-4
  .view (Math.MatMul .local-pos-4) (Math.Add (Float4 0 0 0 1)) >= .view-pos-4
  .proj (Math.MatMul .view-pos-4) >= .screen-pos

  .screen-pos (Shader.WriteGlobal "screenPosition"))

(defshards setup-skybox-pass [atmosphere-wgsl filter-cubemap render-sky-sphere-queue sky-sphere-vs]
  (GFX.BuiltinFeature :Id BuiltinFeatureId.Transform) >> .sky-features
  (GFX.Feature :Shaders [{:Stage ProgrammableGraphicsStage.Vertex
                          :EntryPoint (sky-sphere-vs)
                          :After ["initScreenPosition"]
                          :Before ["writePosition"]}
                         {:Stage ProgrammableGraphicsStage.Fragment
                          :EntryPoint (sky-fs)}]
               :State {:FlipFrontFace true :DepthWrite false :DepthCompare CompareFunction.LessEqual}
               :ViewGenerators (precompute-sky atmosphere-wgsl filter-cubemap)) >> .sky-features

  (render-sky-sphere-queue "sky-sphere-queue" {})
  (GFX.DrawablePass :Features .sky-features :Queue .sky-sphere-queue))

(defshards skybox-pass [atmosphere-wgsl filter-cubemap render-sky-sphere-queue sky-sphere-vs]
  (Setup
   (Float3 -4.0 10.0 2.5) (Math.Normalize) (Set .light-direction :Exposed true)
   (Float3 1 1 1) (Set .light-color :Exposed true)
   (setup-skybox-pass atmosphere-wgsl filter-cubemap render-sky-sphere-queue sky-sphere-vs) >= .sky-pass)
  .sky-pass)
