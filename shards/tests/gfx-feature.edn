(def timestep (/ 1.0 120.0))
(defmesh root)
(def BlendAdd {:Operation BlendOperation.Add :Src BlendFactor.One :Dst BlendFactor.One})
(def BlendAlpha {:Operation BlendOperation.Add :Src BlendFactor.SrcAlpha :Dst BlendFactor.OneMinusSrcAlpha})
(def BlendOne {:Operation BlendOperation.Add :Src BlendFactor.One :Dst BlendFactor.One})

(defshards spin-transform [t location]
  t
  (| (Math.Multiply 0.2) (Math.AxisAngleX) (Math.Rotation) >= .rotX)
  (| (Math.Multiply 0.7) (Math.AxisAngleY) (Math.Rotation) >= .rotY)
  (| (Math.Multiply 0.9) (Math.AxisAngleZ) (Math.Rotation) >= .rotZ)
  location (Math.Translation) (Math.MatMul .rotX) (Math.MatMul .rotY) (Math.MatMul .rotZ))

(defloop test-wire
  (Setup
   0.0 >= .time
   (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) >= .mesh
   (Float3 -1 0 0) (Math.Translation) >= .transform-0
   (Float3 1 0 0) (Math.Translation) >= .transform-1
   (Float3 0 0 -1) (Math.Normalize) >= .light-direction

   0.0 >= .time
   .time (Broadcast "time")

    ; Create render steps
   (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .features
   "vec3<f32>(0.0, 1.0, 0.2)" = .fconst-str
  ;;  {:ComposeWith {:fconst-str .fconst-str}
  ;;   :Shaders [{:Name "lighting"
  ;;              :Stage ProgrammableGraphicsStage.Fragment
  ;;              :EntryPoint (->
  ;;                           (Shader.ReadInput "worldNormal") >= .normal
  ;;                           (Shader.ReadBuffer "lightDirection") >= .light-dir
  ;;                           (Float3 0 0 0) (Math.Subtract .light-dir) >= .inv-light-dir
  ;;                           .normal (Math.Normalize) (Math.Dot .inv-light-dir) (Max 0.0) >= .n-dot-l
  ;;                           (Shader.ReadBuffer "lightColor") (Math.Multiply .n-dot-l)
  ;;                           (| (Float3 0.0) >= .extra-color
  ;;                              (Shader.Literal [.extra-color " = " .fconst-str ";\n"]))
  ;;                           (Math.Add .extra-color)
  ;;                           (Shader.WriteGlobal "lighting"))}
  ;;             {:Name "mainColor"
  ;;              :Stage ProgrammableGraphicsStage.Fragment
  ;;              :EntryPoint (->
  ;;                           (Shader.ReadBuffer "time") >= .time
  ;;                           .time (Math.Multiply 2.0) (Math.Cos) (Math.Divide 2.0) (Math.Add 0.5) >= .wave
  ;;                           (Shader.ReadGlobal "lighting") (ToFloat4) >= .lighting-4
  ;;                           .wave (Math.Multiply (Float4 0 0 0 1)) (Math.Add .lighting-4)
  ;;                           (Shader.WriteOutput "color"))}]
  ;;   :Params {:lightDirection .light-direction
  ;;            :lightColor (Float3 1.0)}
  ;;   :State {:DepthCompare CompareFunction.Less
  ;;           :Blend {:Color BlendAlpha :Alpha BlendOne}}}
  ;;  (GFX.Feature :ViewGenerators
  ;;               (->
  ;;                (Listen "time") >= .time
  ;;                {:time .time})) >> .features
   (GFX.Feature :Shaders [{:Name "lighting"
               :Stage ProgrammableGraphicsStage.Fragment
               :EntryPoint (->
                            (Shader.ReadInput "worldNormal") >= .normal
                            (Shader.ReadBuffer "lightDirection") >= .light-dir
                            (Float3 0 0 0) (Math.Subtract .light-dir) >= .inv-light-dir
                            .normal (Math.Normalize) (Math.Dot .inv-light-dir) (Max 0.0) >= .n-dot-l
                            (Shader.ReadBuffer "lightColor") (Math.Multiply .n-dot-l)
                            (| (Float3 0.0) >= .extra-color
                               (Shader.Literal [.extra-color " = " .fconst-str ";\n"]))
                            (Math.Add .extra-color)
                            (Shader.WriteGlobal "lighting"))}
              {:Name "mainColor"
               :Stage ProgrammableGraphicsStage.Fragment
               :EntryPoint (->
                            (Shader.ReadBuffer "time") >= .time
                            .time (Math.Multiply 2.0) (Math.Cos) (Math.Divide 2.0) (Math.Add 0.5) >= .wave
                            (Shader.ReadGlobal "lighting") (ToFloat4) >= .lighting-4
                            .wave (Math.Multiply (Float4 0 0 0 1)) (Math.Add .lighting-4)
                            (Shader.WriteOutput "color"))}]
                :ComposeWith {:fconst-str .fconst-str}
    :State {:DepthCompare CompareFunction.Less
                        :Blend {:Color BlendAlpha :Alpha BlendOne}}
                :ViewGenerators
                (->
                 (Listen "time" (type Float)) >= .time
                 {:time .time})
                :Params {:lightDirection .light-direction
                         :lightColor (Float3 1.0)}) >> .features
   (GFX.DrawQueue) >= .queue
   (GFX.DrawablePass :Features .features :Queue .queue) >> .render-steps

    ;; Create view
   {:Position (Float3 0 0 8) :Target (Float3 0 0 0)} (Math.LookAt) >= .view-transform
   (GFX.View :View .view-transform) >= .view)
  (GFX.MainWindow
   :Title "SDL Window" :Width 1280 :Height 720 
   :Contents
   (->
    .time (Math.Add timestep) > .time
    .time (Broadcast "time")

    (spin-transform .time (Float3 -0.6 0 0))
    (GFX.Drawable :Mesh .mesh) (GFX.Draw .queue)

    (spin-transform (-> .time (Math.Multiply 0.5)) (Float3 0.6 0 0))
    (GFX.Drawable :Mesh .mesh) (GFX.Draw .queue)

    (GFX.Render :Steps .render-steps :View .view))))

(schedule root test-wire)
(if (run root timestep 100) nil (throw "Root tick failed"))
