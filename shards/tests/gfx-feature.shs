@define(timestep #(1.0 | Math.Divide(120.0)))
@mesh(root)
@define(blendAdd {Operation: BlendOperation::Add Src: BlendFactor::One Dst: BlendFactor::One})
@define(blendAlpha {Operation: BlendOperation::Add Src: BlendFactor::SrcAlpha Dst: BlendFactor::OneMinusSrcAlpha})
@define(blendOne {Operation: BlendOperation::Add Src: BlendFactor::One Dst: BlendFactor::One})

@template(spin-transform [t location] {
  t |
  {Math.Multiply(0.2) | Math.AxisAngleX | Math.Rotation >= rotX} |
  {Math.Multiply(0.7) | Math.AxisAngleY | Math.Rotation >= rotY} |
  {Math.Multiply(0.9) | Math.AxisAngleZ | Math.Rotation >= rotZ}
  location | Math.Translation | Math.MatMul(rotX) | Math.MatMul(rotY) | Math.MatMul(rotZ)
})

@wire(test-wire {
  Once({
    0.0 >= time
    GFX.BuiltinMesh(Type: BuiltinMeshType::Cube) >= mesh
    @f3(-1 0 0) | Math.Translation >= transform-0
    @f3(1 0 0) | Math.Translation >= transform-1
    @f3(0 0 -1) | Math.Normalize>= light-direction

    0.0 >= time
    time | Broadcast("time")

    ; Create render steps
    GFX.BuiltinFeature(BuiltinFeatureId::Transform) >> features
    "vec3<f32>(0.0, 1.0, 0.2)" = fconst-str
    ; {ComposeWith: {fconst-str: fconst-stre}
    ;  Shaders: [{Name: "lighting"
    ;             Stage: ProgrammableGraphicsStage::Fragment
    ;             EntryPoint: {
    ;               Shader.ReadInput("worldNormal") >= normal
    ;               Shader.ReadBuffer("lightDirection") >= light-dir
    ;               @f3(0 0 0) | Math.Subtract(light-dir) >= inv-light-dir
    ;               normal | Math.Normalize | Math.Dot(inv-light-dir) | Max(0.0) >= n-dot-l
    ;               Shader.ReadBuffer("lightColor") | Math.Multiply(n-dot-l) |
    ;               {@f3(0.0) >= extra-color
    ;                Shader.Literal([extra-color " = " fconst-str ";\n"])} |
    ;                Math.Add(extra-color) |
    ;                Shader.WriteGlobal("lighting")}
    ;             {Name: "mainColor"
    ;              Stage: ProgrammableGraphicsStage::Fragment
    ;              EntryPoint: {
    ;               Shader.ReadBuffer("time") >= time
    ;               time | Math.Multiply(2.0) | Math.Cos | Math.Divide(2.0) | Math.Add(0.5) >= wave
    ;               Shader.ReadGlobal("lighting") | ToFloat4 >= lighting-4
    ;               wave | Math.Multiply(@f4(0 0 0 1)) | Math.Add(lighting-4) |
    ;               Shader.WriteOutput("color")}}}]
    ;   Params: {lightDirection: light-direction
    ;            lightColor: @f3(1.0)}
    ;   State: {DepthCompare: CompareFunction::Less
    ;           Blend: {Color: @blendAlpha Alpha: @blendOne}}} |
    ; GFX.Feature(ViewGenerators: {
    ;   Listen("time") >= time
    ;   {time: time}
    ; }) >> features
    GFX.Feature(
      Shaders: [{Name: "lighting"
                Stage: ProgrammableGraphicsStage::Fragment
                EntryPoint: {
                  Shader.ReadInput("worldNormal") >= normal
                  Shader.ReadBuffer("lightDirection") >= light-dir
                  @f3(0 0 0) | Math.Subtract(light-dir) >= inv-light-dir
                  normal | Math.Normalize | Math.Dot(inv-light-dir) | Max(0.0) >= n-dot-l
                  Shader.ReadBuffer("lightColor") | Math.Multiply(n-dot-l) |
                  {@f3(0.0) >= extra-color
                   Shader.Literal([extra-color " = " fconst-str ";\n"])} |
                   Math.Add(extra-color) |
                   Shader.WriteGlobal("lighting")}}
                {Name: "mainColor"
                 Stage: ProgrammableGraphicsStage::Fragment
                 EntryPoint: {
                  Shader.ReadBuffer("time") >= time
                  time | Math.Multiply(2.0) | Math.Cos | Math.Divide(2.0) | Math.Add(0.5) >= wave
                  Shader.ReadGlobal("lighting") | ToFloat4 >= lighting-4
                  wave | Math.Multiply(@f4(0 0 0 1)) | Math.Add(lighting-4) |
                  Shader.WriteOutput("color")}}]
      ComposeWith: {fconst-str: fconst-str}
      State: {DepthCompare: CompareFunction::Less
               Blend: {Color: @blendAlpha Alpha: @blendOne}}
      ViewGenerators: {
        Listen("time" @type(Type::Float)) >= time
        {time: time}}
      Params: {lightDirection: light-direction
               lightColor: @f3(1.0)}) >> features
    GFX.DrawQueue >= queue
    GFX.DrawablePass(Features: features
                     Queue: queue) >> render-steps

    ; Create view
    {Position: @f3(0 0 5) Target: @f3(0 0 0)} | Math.LookAt >= view-transform
    GFX.View(View: view-transform) >= view
  })
  GFX.MainWindow(
    Title: "SDL Window" Width: 1280 Height: 720
    Contents: {
      time | Math.Add(@timestep) > time
      time | Broadcast("time")

      @spin-transform(time @f3(-0.6 0 0))
      GFX.Drawable(Mesh: mesh) | GFX.Draw(queue)

      @spin-transform((time | Math.Multiply(0.5)) @f3(0 0.6 0))
      GFX.Drawable(Mesh: mesh) | GFX.Draw(queue)

      GFX.Render(View: view Steps: render-steps)
    }
  )
} Looped: true)

@schedule(root test-wire)
@run(root FPS: 120 Iterations: 100) | Assert.Is(true)