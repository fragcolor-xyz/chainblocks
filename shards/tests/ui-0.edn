; SPDX-License-Identifier: BSD-3-Clause
; Copyright Â© 2022 Fragcolor Pte. Ltd.

;; Notes:
;;   This file contains unit tests for the UI shards.
;;   It is not meant to be realistic. For such samples, look at egui-demo.edn.

(defmesh main)
(def timestep (/ 1.0 60.0))
(def duration 60)
(def input "**input**")

;; context
(defloop context-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    input
    (UI .ui-draw-queue (-> "hello" = .hello))
    ;; input passthrough
    (Assert.Is input :Break true)
    ;; exposed variable
    .hello (ExpectString)

    (GFX.Render :Steps .render-steps))))
(schedule main context-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; window
(defloop window-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      input
      (UI.Window
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)))
      ;; input passthrough
      (Assert.Is input :Break true)))

    (GFX.Render :Steps .render-steps))))
(schedule main window-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; scope
(defloop scope-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.Window
       :Contents
       (->
        input
        (UI.Scope
         :Contents
         (->
          ;; input pass into
          (Assert.Is input :Break true)))
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main scope-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; area
(defloop area-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      input
      (UI.Area
       :Anchor Anchor.TopLeft
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)
        "TopLeft" (UI.Label)))
      input
      (UI.Area
       :Anchor Anchor.Top
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)
        "Top" (UI.Label)))
      input
      (UI.Area
       :Anchor Anchor.TopRight
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)
        "TopRight" (UI.Label :Wrap false)))
      input
      (UI.Area
       :Anchor Anchor.Left
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)
        "Left" (UI.Label)))
      input
      (UI.Area
       :Anchor Anchor.Center
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)
        "Center" (UI.Label)))
      input
      (UI.Area
       :Anchor Anchor.Right
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)
        "Right" (UI.Label)))
      input
      (UI.Area
       :Anchor Anchor.BottomLeft
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)
        "BottomLeft" (UI.Label)))
      input
      (UI.Area
       :Anchor Anchor.Bottom
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)
        "Bottom" (UI.Label)))
      input
      (UI.Area
       :Anchor Anchor.BottomRight
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)
        "BottomRight" (UI.Label :Wrap false)))
        ;; content passthrough
      (Assert.Is "BottomRight" :Break true)))

    (GFX.Render :Steps .render-steps))))
(schedule main area-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; panels
(defloop panels-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      input
      (UI.TopPanel
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)))
      (UI.LeftPanel
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)))
      (UI.RightPanel
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)))
      (UI.BottomPanel
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)))
      (UI.CentralPanel
       :Contents
       (->
        ;; input pass into
        (Assert.Is input :Break true)))
        ;; input passthrough
      (Assert.Is input :Break true)))

    (GFX.Render :Steps .render-steps))))
(schedule main panels-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; collapsing header
(defloop collapsing-header-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Collapsing
         :Heading (UI.Button "Heading")
         :DefaultOpen true
         :Contents
         (->
          ;; input pass into
          (Assert.Is input :Break true)))
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main collapsing-header-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; columns
(defloop columns-header-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Columns
         [(->
           ;; input pass into
           (Assert.Is input :Break true))
          (->
           ;; input pass into
           (Assert.Is input :Break true))])
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main columns-header-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; disable
(defloop disable-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Disable
         :Disable true
         :Contents
         (->
          ;; input pass into
          (Assert.Is input :Break true)))
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main disable-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; frame
(defloop frame-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Frame
         :InnerMargin (float4 10) :OuterMargin (float4 0) :Rounding (float4 5)
         :FillColor (color 32 32 128)
         :StrokeColor (color 255 64 255) :StrokeWidth 8.0
         :Contents
         (->
          ;; input pass into
          (Assert.Is input :Break true)))
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main frame-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; group
(defloop group-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Group
         :Contents
         (->
          ;; input pass into
          (Assert.Is input :Break true)))
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main group-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; indent
(defloop indent-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Indent
         :Contents
         (->
          ;; input pass into
          (Assert.Is input :Break true)))
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main indent-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; horizontal layout
(defloop horizontal-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Horizontal
         :Contents
         (->
          ;; input pass into
          (Assert.Is input :Break true)))
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main horizontal-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; scroll area
(defloop scroll-area-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.ScrollArea
         :Horizontal true :Vertical true
         :AlwaysShow true
         :Contents
         (->
          ;; input pass into
          (Assert.Is input :Break true)))
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main scroll-area-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; vertical layout
(defloop vertical-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Vertical
         :Contents
         (->
          ;; input pass into
          (Assert.Is input :Break true)))
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main vertical-test)
(if (run main timestep duration) nil (throw "Root tick failed"))

;; separator
(defloop separator-test
  (GFX.MainWindow
   :Contents
   (->
    (Setup
     (GFX.DrawQueue) >= .ui-draw-queue
     (GFX.UIPass .ui-draw-queue) >> .render-steps)

    (UI
     .ui-draw-queue
     (->
      (UI.CentralPanel
       :Contents
       (->
        input
        (UI.Separator)
        ;; input passthrough
        (Assert.Is input :Break true)))))

    (GFX.Render :Steps .render-steps))))
(schedule main separator-test)
(if (run main timestep duration) nil (throw "Root tick failed"))
