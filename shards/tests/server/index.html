<!DOCTYPE html>
<html>

<head>
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
    }

    #canvas-container {
      width: 60%;
      height: 100%;
      position: relative;
    }

    #canvas {
      width: 100%;
      height: 100%;
    }

    #current-action {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      border-radius: 4px;
      display: none;
    }

    #log-container {
      width: 40%;
      height: 100%;
      overflow-y: auto;
      background: #f0f0f0;
      padding: 10px;
      font-family: monospace;
    }
  </style>
</head>

<body>
  <div id="canvas-container">
    <canvas id="canvas"></canvas>
    <div id="current-action"></div>
  </div>
  <div id="log-container"></div>

  <script type="module">
    const logContainer = document.getElementById('log-container');
    const canvas = document.getElementById('canvas');
    const currentAction = document.getElementById('current-action');
    let isProcessingAction = false;

    function parseWindowSearchOpts(query_) {
      var opts = {};
      var query = query_ || window.location.search.substring(1);
      var vars = query.split('&');
      for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split('=');
        opts[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return opts;
    }
    const urlQuery = parseWindowSearchOpts();

    function log(message) {
      const div = document.createElement('div');
      div.textContent = message;
      logContainer.appendChild(div);
      logContainer.scrollTop = logContainer.scrollHeight;
    }

    const SPDLOG_LEVEL_TRACE = 0;
    const SPDLOG_LEVEL_DEBUG = 1;
    const SPDLOG_LEVEL_INFO = 2;
    const SPDLOG_LEVEL_WARN = 3;
    const SPDLOG_LEVEL_ERROR = 4;
    const SPDLOG_LEVEL_CRITICAL = 5;
    const SPDLOG_LEVEL_OFF = 6;
    let instance = {};
    import ShardsModule from "./bin/shards-mt.js";

    async function loadShards() {
      const response = await fetch("./bin/shards-mt.wasm");
      if (!response.ok) {
        log(`Failed to fetch wasm: ${response.statusText}`);
      }

      const wasmBytes = await response.arrayBuffer();
      const mod = instance.module = await ShardsModule({
        wasmBinary: new Uint8Array(wasmBytes),
      });
      log("Module loaded");


      instance.setLoggerLevel = (loggerName, level) => {
        const tmpStr = mod.stringToNewUTF8(loggerName);
        mod._shardsSetLoggerLevel(tmpStr, level);
        mod._free(tmpStr);
      };

      if (urlQuery["trace"] !== "1") {
        instance.setLoggerLevel("gfx", SPDLOG_LEVEL_TRACE);
        instance.setLoggerLevel("wgpu", SPDLOG_LEVEL_TRACE);
        instance.setLoggerLevel("shards", SPDLOG_LEVEL_TRACE);
        instance.setLoggerLevel("http", SPDLOG_LEVEL_TRACE);
      }
      instance.setLoggerLevel("audio", SPDLOG_LEVEL_DEBUG);
    }

    log("Loading shards...");
    await loadShards();
    const mod = instance.module;
    mod._shardsInit();

    // Add log polling function
    const countPtr = mod._malloc(4);
    function pollLogs() {
      const mod = instance.module;
      mod._shardsLockLogBuffer();
      try {
        const messagesPtr = mod._shardsGetLogMessages(countPtr);
        const count = mod.HEAP32[countPtr >> 2];

        if (count > 0 && messagesPtr !== 0) {
          const messageSize = 16; // size of MessageRep struct (ptr + ptr + int + int)
          for (let i = 0; i < count; i++) {
            const offset = messagesPtr + (i * messageSize);
            const msgPtr = mod.HEAP32[offset >> 2];
            const filePtr = mod.HEAP32[(offset + 4) >> 2];
            const level = mod.HEAP32[(offset + 12) >> 2];

            const msg = mod.UTF8ToString(msgPtr);
            const file = mod.UTF8ToString(filePtr);

            let prefix = '';
            switch (level) {
              case 0: prefix = '[trace] '; break;
              case 1: prefix = '[debug] '; break;
              case 2: prefix = '[info] '; break;
              case 3: prefix = '[warn] '; break;
              case 4: prefix = '[error] '; break;
              case 5: prefix = '[critical] '; break;
            }

            log(`${prefix}${file ? `[${file}] ` : ''}${msg}`);
          }
        }
      } finally {
        mod._shardsUnlockLogBuffer();
      }
      setTimeout(pollLogs, 100);
    }
    pollLogs();

    async function processAction(action) {
      isProcessingAction = true;
      currentAction.textContent = JSON.stringify(action);
      currentAction.style.display = 'block';
      log(`Processing action: ${JSON.stringify(action)}`);

      // Dummy completion after 3 seconds
      await new Promise(resolve => setTimeout(resolve, 3000));

      currentAction.style.display = 'none';
      isProcessingAction = false;
      log('Action completed');

      // Delete completed action
      await fetch('/control', {
        method: 'DELETE'
      });
    }

    async function pollControl() {
      if (!isProcessingAction) {
        try {
          const response = await fetch('/control');
          const actions = await response.json();

          if (actions && actions.length > 0) {
            await processAction(actions[0]);
          }
        } catch (error) {
          log(`Error polling control: ${error}`);
        }
      }

      setTimeout(pollControl, 1000);
    }

    pollControl();
  </script>
</body>

</html>