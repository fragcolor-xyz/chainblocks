; SPDX-License-Identifier: BSD-3-Clause
; Copyright Â© 2022 Fragcolor Pte. Ltd.

(def timestep (/ 1.0 120.0))
(def duration 600)

(def ground-extent 50)
(def ground-thickness 0.5)
(def ground-y -4)
(def obj-count 100)

(defloop main-wire
  (Setup
   ; define shapes
   (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) = .cube
   (GFX.BuiltinMesh :Type BuiltinMeshType.Plane) = .plane
   (GFX.BuiltinMesh :Type BuiltinMeshType.Sphere) = .sphere

   ; ground
   [(float4 ground-extent 0 0 0)
    (float4 0 0 (- ground-extent) 0)
    (float4 0 1 0 0)
    (float4 0 (+ ground-thickness ground-y) 0 1)]
   (GFX.Drawable :Mesh .plane
                 :Params {:baseColor (float4 0.8 0.55 0.95 1)}) >= .ground-drawable

   ; define some physics shapes
   (Physics.Cuboid :HalfExtents (float3 0.5)) = .cube-pshape
   (Physics.Ball :Radius 0.5) = .sphere-pshape
   (Physics.Cuboid :HalfExtents (float3 (/ ground-extent 2) ground-thickness (/ ground-extent 2))) = .ground-pshape

   (GFX.DrawQueue) >= .queue
   
   ; define rendering features
   (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .features
   (GFX.BuiltinFeature BuiltinFeatureId.BaseColor) >> .features
   (GFX.DrawablePass :Features .features :Queue .queue) >> .render-steps

   ; define a view
   {:Position (float3 50 40 50) :Target (float3 0 0 0)} (Math.LookAt) = .view-transform
   (GFX.View :View .view-transform) = .view)

  (GFX.MainWindow
   :Title "Physics" :Width 1280 :Height 720 
   :Contents
   (->
    ; physics simulation
    (Physics.Simulation)
    (Physics.KinematicBody .ground-pshape (float3 0 ground-y 0))

    ; initialize transforms and  associate a physics body to each shape
    (map
     (fn* [n]
          (->
           (float3 0 n 0) (Math.Translation)
           >= (ContextVar (str "transform-" n))

           (Physics.DynamicBody
            :Position (float3 0 n 0)
            :Shapes (if (= (% n 2) 0) .cube-pshape .cube-pshape)
            :Name (str "rb" n)) > (ContextVar (str "transform-" n))))
     (range 1 obj-count))

    ; draw everything
    .ground-drawable (GFX.Draw .queue)

    ; cubes and spheres instances
    (map
     (fn* [n]
          (-> (ContextVar (str "transform-" n))
              (GFX.Drawable
               :Mesh (if (= (% n 2) 0) .cube .cube)
               :Params
               {:baseColor (float4 (* (/ n obj-count) 2.0) (* (- 1.0 (/ n obj-count)) 2.0) 0 1)})

              >> .drawables))
     (range 1 obj-count))
    .drawables (GFX.Draw .queue)

    ; final render
    (GFX.Render :Steps .render-steps :View .view))))

(defmesh root)
(schedule root main-wire)
(run root timestep duration)
