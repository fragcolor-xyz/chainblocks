# The union libary is responsible for combining all required shards modules
# into a single library alongside the registration and indexing boilerplate

set(union_SOURCES union.cpp)

add_library(shards-union ${union_SOURCES})
target_link_libraries(shards-union shards-core)

get_property(SHARDS_MODULE_TARGETS GLOBAL PROPERTY SHARDS_MODULE_TARGETS)

if(NOT SHARDS_INLINE_EVERYTHING)
  # Compile normally inlined sources separately
  # NOTE: You should make sure the source files listed here are included inside core_inlined.cpp as well
  target_sources(shards-union PRIVATE
    ../core/runtime.cpp
  )
endif()

foreach(TARGET_NAME ${SHARDS_MODULE_TARGETS})
  get_property(MODULE_ID TARGET ${TARGET_NAME} PROPERTY SHARDS_MODULE_ID)
  is_module_enabled(MODULE_ENABLED ${MODULE_ID})

  if(${MODULE_ENABLED})
    # message(STATUS "shards-union: Adding module ${TARGET_NAME} (id: ${MODULE_ID})")
    target_link_libraries(shards-union ${TARGET_NAME})
    list(APPEND ENABLED_MODULE_IDS ${MODULE_ID})
    list(APPEND ENABLED_MODULE_TARGETS ${TARGET_NAME})
  endif()
endforeach()

# message(STATUS "ENABLED_MODULE_IDS ${ENABLED_MODULE_IDS}")
# message(STATUS "ENABLED_MODULE_TARGETS ${ENABLED_MODULE_TARGETS}")

# Generate headers
set(GENERATED_ROOT_DIR "${CMAKE_CURRENT_BINARY_DIR}/generated")
set(GENERATED_INCLUDE_DIR "${CMAKE_CURRENT_BINARY_DIR}/generated/shards")
set(GENERATED_INLINE_HEADER "${GENERATED_INCLUDE_DIR}/inlined.hpp")
set(GENERATED_TEMP "${CMAKE_CURRENT_BINARY_DIR}/temp.cpp")

# Add include path to shards core so it can inline the code that is generated here
target_include_directories(shards-core PUBLIC ${GENERATED_ROOT_DIR})

file(MAKE_DIRECTORY ${GENERATED_INCLUDE_DIR})
file(WRITE ${GENERATED_TEMP}
  "// This file is generated by CMake\n"
  "#ifndef SHARDS_INLINED_HPP\n"
  "#define SHARDS_INLINED_HPP\n"
  "\n"
  "#include <stdint.h>\n"
  "\n"
  "namespace shards {\n"
  "struct InlineShard {\n"
  "  enum Type : uint32_t {\n")

foreach(MODULE_ID MODULE_TARGET IN ZIP_LISTS ENABLED_MODULE_IDS ENABLED_MODULE_TARGETS)
  get_property(INLINE_SHARDS TARGET ${MODULE_TARGET} PROPERTY SHARDS_MODULE_INLINE_SHARDS)
  if(INLINE_SHARDS)
    foreach(INLINE_SHARD ${INLINE_SHARDS})
      file(APPEND ${GENERATED_TEMP} "    "
        "${INLINE_SHARD},\n")
    endforeach()

    list(APPEND MODULES_WITH_INLINE_IDS "${MODULE_ID}")
  endif()

  get_property(INLINE_SOURCES TARGET ${MODULE_TARGET} PROPERTY SHARDS_MODULE_INLINE_SOURCES)
  if(INLINE_SOURCES)
    message(STATUS "INLINING ${INLINE_SOURCES}")
    foreach(INLINE_SOURCE ${INLINE_SOURCES})
      file(RELATIVE_PATH REL_INLINE_SRC_PATH "${GENERATED_INCLUDE_DIR}" "${INLINE_SOURCE}")
      list(APPEND RELATIVE_INLINE_SOURCES ${REL_INLINE_SRC_PATH})
      list(APPEND RELATIVE_INLINE_SOURCES_MODULE_IDS ${MODULE_ID})
    endforeach()
  endif()

endforeach()

file(APPEND ${GENERATED_TEMP}
  "  };\n"
  "};\n"
  "}\n"
  "#endif // SHARDS_INLINED_HPP\n")
file(COPY_FILE ${GENERATED_TEMP} ${GENERATED_INLINE_HEADER} ONLY_IF_DIFFERENT)

# Generate inline source bindings
set(GENERATED_INLINE_SOURCE "${GENERATED_INCLUDE_DIR}/inlined.cpp")
file(WRITE ${GENERATED_TEMP}
  "// This file is generated by CMake\n"
  "#include <shards/union/inlined_prelude.cpp>\n"
  "#include <shards/core/inline.hpp>\n")

if(SHARDS_INLINE_EVERYTHING)
  # Include module-provided inline sources
  foreach(REL_INLINE_SRC MODULE_ID IN ZIP_LISTS RELATIVE_INLINE_SOURCES RELATIVE_INLINE_SOURCES_MODULE_IDS)
    file(APPEND ${GENERATED_TEMP} 
      "#define SHARDS_THIS_MODULE_ID ${MODULE_ID}\n"
      "#include \"${REL_INLINE_SRC}\"\n"
      "#undef SHARDS_THIS_MODULE_ID\n"
      )
    message(STATUS "Shards: Inlining ${REL_INLINE_SRC}")
  endforeach()

  # Include the core inline source file here
  file(APPEND ${GENERATED_TEMP} "#include <shards/core/core_inlined.cpp>\n")
endif()

file(APPEND ${GENERATED_TEMP} "\n"
  "namespace shards {\n")

# Set inline ID declaration (when not inlining)
if(NOT SHARDS_INLINE_EVERYTHING)
  foreach(MODULE_ID ${MODULES_WITH_INLINE_IDS})
    file(APPEND ${GENERATED_TEMP}
      "ALWAYS_INLINE bool setInlineShardId_${MODULE_ID}(Shard*, std::string_view);\n"
    )
  endforeach()

  file(APPEND ${GENERATED_TEMP} "\n")
endif()

file(APPEND ${GENERATED_TEMP}
  "ALWAYS_INLINE void setInlineShardId(Shard *shard, std::string_view name) {\n")

foreach(MODULE_ID ${MODULES_WITH_INLINE_IDS})
  file(APPEND ${GENERATED_TEMP}
    "  if (setInlineShardId_${MODULE_ID}(shard, name))\n"
    "    return;\n")
endforeach()

file(APPEND ${GENERATED_TEMP} "}\n\n")

# Activation declaration (when not inlining)
if(NOT SHARDS_INLINE_EVERYTHING)
  foreach(MODULE_ID ${MODULES_WITH_INLINE_IDS})
    file(APPEND ${GENERATED_TEMP}
      "ALWAYS_INLINE bool activateShardInline_${MODULE_ID}(Shard*, SHContext*, const SHVar&, SHVar&);\n"
    )
  endforeach()

  file(APPEND ${GENERATED_TEMP} "\n")
endif()

file(APPEND ${GENERATED_TEMP}
  "ALWAYS_INLINE bool activateShardInline(Shard *shard, SHContext *context, const SHVar &input, SHVar &output) {\n")

foreach(MODULE_ID ${MODULES_WITH_INLINE_IDS})
  file(APPEND ${GENERATED_TEMP}
    "  if (activateShardInline_${MODULE_ID}(shard, context, input, output))\n"
    "    return true;\n")
endforeach()

file(APPEND ${GENERATED_TEMP}
  "  return false;\n"
  "}\n\n")

file(APPEND ${GENERATED_TEMP} "}\n")
file(COPY_FILE ${GENERATED_TEMP} ${GENERATED_INLINE_SOURCE} ONLY_IF_DIFFERENT)

target_sources(shards-union PRIVATE ${GENERATED_INLINE_SOURCE})
set_source_files_properties(${GENERATED_INLINE_SOURCE} PROPERTIES GENERATED TRUE)

# Registry header
set(GENERATED_REGISTRY_HEADER "${GENERATED_INCLUDE_DIR}/registry.hpp")
file(WRITE ${GENERATED_TEMP}
  "// This file is generated by CMake\n"
  "#ifndef SHARDS_REGISTRY_HPP\n"
  "#define SHARDS_REGISTRY_HPP\n")

foreach(MODULE_ID ${ENABLED_MODULE_IDS})
  string(TOUPPER ${MODULE_ID} MODULE_ID_UPPPER)
  file(APPEND ${GENERATED_TEMP} "#define SHARDS_WITH_${MODULE_ID_UPPPER} 1\n")
endforeach()

file(APPEND ${GENERATED_TEMP} "#endif // SHARDS_REGISTRY_HPP\n")
file(COPY_FILE ${GENERATED_TEMP} ${GENERATED_REGISTRY_HEADER} ONLY_IF_DIFFERENT)

# Shard registry
set(GENERATED_REGISTRY_SOURCE "${GENERATED_INCLUDE_DIR}/registry.cpp")
file(WRITE ${GENERATED_TEMP}
  "// This file is generated by CMake\n"
  "#include <shards/shards.hpp>\n"
  "\n")

foreach(MODULE_TARGET ${ENABLED_MODULE_TARGETS})
  get_property(REGISTER_FNS TARGET ${MODULE_TARGET} PROPERTY SHARDS_MODULE_REGISTER_FNS)

  foreach(REGISTER_FN ${REGISTER_FNS})
    list(APPEND ALL_REGISTER_FNS ${REGISTER_FN})
  endforeach()

  list(APPEND MODULES_WITH_INLINE_IDS "${MODULE_ID}")
endforeach()

foreach(FN ${ALL_REGISTER_FNS})
  file(APPEND ${GENERATED_TEMP} "extern \"C\" void shardsRegister_${FN}(SHCore* core);\n")
endforeach()

file(APPEND ${GENERATED_TEMP} "\n"
  "namespace shards {\n"
  "void registerModuleShards(SHCore* core) {\n")

foreach(FN ${ALL_REGISTER_FNS})
  file(APPEND ${GENERATED_TEMP} "  shardsRegister_${FN}(core);\n")
endforeach()

file(APPEND ${GENERATED_TEMP} "}\n")
file(APPEND ${GENERATED_TEMP} "}\n")
file(COPY_FILE ${GENERATED_TEMP} ${GENERATED_REGISTRY_SOURCE} ONLY_IF_DIFFERENT)

target_sources(shards-union PRIVATE ${GENERATED_REGISTRY_SOURCE})
set_source_files_properties(${GENERATED_REGISTRY_SOURCE} PROPERTIES GENERATED TRUE)
