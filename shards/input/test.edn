(defmesh root-mesh)
(defmesh gfx-mesh)

(defwire render-ui
  (Inputs.Detached
   .input-context
   :Name "ui"
   :Priority 10
   :Contents (->
              (UI .ui-queue (-> (UI.Window
                                 :Title "Greetings" :Flags WindowFlags.NoCollapse
                                 :Contents
                                 (->
                                  (Inputs.DebugUI)

                                  "Hello shards!" (UI.Label)
                                  (Setup "Text Field" >= .text)
                                  (UI.TextField .text)
                                  (UI.Button :Label "Reset camera"
                                             :Action (->
                                                      (Msg "Clicked")
                                                      .init-camera-matrix > .camera-matrix)))))))
   :HandleInputs (->
                  ;; .test (Log "Input thread")
                  nil)))

(defwire render-gizmos
  (Inputs.Detached
   .input-context
   :Name "gizmos"
   :Priority 3
   :Contents (->
              (Gizmos.Context
               :Queue .gizmo-queue :View .view :Content
               (->

                (Float3 1 0 0) >= .xbase
                (Float3 0 1 0) >= .ybase
                (Float3 0 0 1) >= .zbase
                (Gizmos.Rect :Center (Float3 0.0) :XBase .xbase :YBase .zbase :Color (Float4 1.0 0.2 1.0 1.0) :Thickness 4)
                .object-matrix (Gizmos.Translation) > .object-matrix
                ))))
  
  ; Test cube
  (Setup
   (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) >= .mesh)
  (Float3 0.0 0 0) (Math.Translation) (GFX.Drawable :Mesh .mesh)
  (GFX.Draw .gizmo-queue);
  )

(defwire update-camera
  (Inputs.Detached
   .input-context
   :Name "camera"
   :Priority 0
   :Contents (->
              .camera-matrix
              (FreeCamera :ScrollSpeed 0.1) > .camera-matrix)))
;; ))

(defloop gfx
  (Setup
   (Listen "input-init") = .input-context
   (GFX.DrawQueue) >= .ui-queue
   (GFX.DrawQueue) >= .gizmo-queue
   {:Position (Float3 0 0 3.0)  :Target (Float3 0.0)}
   (Math.LookAt) (Math.Inverse) = .init-camera-matrix
   >= .camera-matrix
   (Math.MatIdentity) >= .object-matrix)

  (Once :Every (/ 1.0 40.0)
        :Action
        (->
         (Do update-camera)
         .camera-matrix (Math.Inverse) = .view-matrix
         (GFX.View :View .view-matrix) = .view
         (Do render-ui)
         (Do render-gizmos)
         (Animation.Timer) = .time
         (GFX.Renderer
          :Window .input-context
          :Contents
          (->
           {:Params {:time .time
                     :view .camera-matrix
                     :obj .object-matrix}
            :EntryPoint (->
                         (Shader.ReadBuffer "viewport") = .viewport
                         .viewport (Take 2) = .vw .viewport (Take 3) = .vh
                         (Float2 .vw .vh) = .resolution
                         (Shader.ReadInput "texCoord0") (Math.Multiply .resolution) = .coord
                         (Shader.ReadBuffer "time") = .time
                         (Shader.ReadBuffer "view") = .view
                         (Shader.ReadBuffer "obj") = .obj
                         (Shader.Literal :Type ShaderLiteralType.Header :Source (slurp "test.wgsl"))
                         (Shader.Literal
                          ["mainF(" .coord "," .view "," .obj "," .resolution "," .time ")"] :OutputDimension 4)
                         (Shader.WriteOutput "color") ; End shader
                         )}(GFX.EffectPass) >> .render-steps

           (GFX.BuiltinFeature BuiltinFeatureId.Transform) >> .gizmo-features
           (GFX.BuiltinFeature BuiltinFeatureId.BaseColor) >> .gizmo-features
           {:Features .gizmo-features :Queue .gizmo-queue
            :Outputs [{:Name "color"}
                      {:Name "depth" :Clear true}]} (GFX.DrawablePass) >> .render-steps
           (GFX.UIPass .ui-queue) >> .render-steps
           (GFX.Render :View .view :Steps .render-steps))))))

(defloop start
  (GFX.MainWindow
   :Title "Detached Input Test" :Width 1280 :Height 720
   :Contents (-> nil))
  = .input-context

  ; Send this to the graphics thread
  (Setup
   .input-context (Broadcast "input-init")))

(schedule root-mesh start)
(schedule gfx-mesh gfx)

(if (run-many [root-mesh gfx-mesh] (/ 1.0 500.0)) nil (throw "root-mesh tick failed"))
