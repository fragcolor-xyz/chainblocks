"Hello World!" | Log
@x-defined | Log

Repeat({
  = input-var
  """hello
 	"Hello"
"""

  1 | IsMore(2) | Assert.Is(true)
  @i3(2 3 4) | Log | {1 | Assert.Is(1)} ; this is a Sub({})
  | Assert.Is(@i3(2 3 4))
  Do(walk)
  2 | Math.Add(2) | Log | (3 | Math.Add(3) | Log) | #(false | Assert.Is(true)) | Log
  			2.2 | Log | Log >= rare/pose
  2.2 | Log | Log > number ; hello
  2.2 | Log | Log = number
  2.2 | Log | Log = number
  2.2 | Math.Add(2.0) | Log | Log
  2.2 | Math.Add((3 | Math.Add(3))) | Log | Log
  [1 2 3] | Log
  {a: 1 y: 2 Z: 3 22: 2 [1 2] : "hello"} | Log = table
  table | Log
  table:a:b | Log
  {} | Log
  1 >> seq
  2 >> seq
  0x2234 >> seq
  seq:0 | Log
  number | Math.Multiply(2.0) | Math.Multiply(Operand: seq:0 Type::String)
  ; notice no |, we inject always a `nil` in front of a Pipeline,
  ; if the next shard input type is not None
  {a: 1 b: 2} | {ToString | Assert.Is("{a: 1 b: 2}") | Log} | Log = t t:a | Log | Assert.Is(1) t:b | Log | Assert.Is(2)
  Repeat({ ; shards
    10 | Log
  } Times: 3 Until: #(1))

  10 | If({ ; shards
    10 | Log
  } Else: {
    20 | Log
  }) | Log
} Times: 3)

Schedule(root main)
Run(root)

a | Math.Add((a | Math.Subtract(c))) ; generate temps and such at runtime

a | Math.Add(#(a | Math.Subtract(c))) ; run at eval time and write result

@wire(w1 {
  Msg("Hello")
})

@wire(w2 {
  Msg("Hello")
})

@exit
@exit()

Do(w1)
Do(w2)

; comment
