(def timestep (/ 1.0 120.0))

(defpure palette
  (| (Float3 1.0) >= .result)
  (When (Is 0) (-> (Float3 0.8 0.4 0.1) > .result))
  (When (Is 3) (-> (Float3 0.4 0.3 0.9) > .result))
  (When (Is 1) (-> (Float3 0.94 0.3 0.25) > .result))
  (When (Is 2) (-> (Float3 0.2 1.0 0.1) > .result))
  (When (Is 4) (-> (Float3 0.5 0.5 0.8) > .result))
  (When (Is 5) (-> (Float3 0.5 0.3 0.1) > .result))
  .result)

(defpure palette-f
  (Math.Multiply 5.0)
  (| = .in)
  (| (Math.Floor) >= .prev)
  (| (Math.Ceil) >= .next)
  .prev (ToInt) (Do palette) >= .color-a
  .next (ToInt) (Do palette) >= .color-b
  .prev (Math.Subtract .prev)
  .in (Math.Subtract .prev) (Math.Lerp .color-a .color-b))

(defpure ucos
  (Math.Cos) (Math.Multiply 0.5) (Math.Add 0.5))

(defpure plasma
  (Math.Add (Float2 0.3 -0.5)) (Math.Multiply 4.0)
  (| (Take 0) >= .u) (| (Take 1) >= .v)
  (Shader.ReadBuffer "time") (Math.Multiply 0.8) >= .time
  .v (Math.Add .time) > .v

  .time (Math.Add .u) >= .t0
  .time (Math.Add .v) >= .t1
  .time (Math.Add .v) (Math.Add .u) >= .t2
  .time (Math.Add .v) (Math.Multiply 0.04) >= .t3
  .t2 (Math.Cos) (Math.Add .t1) (Math.Cos) (Math.Multiply 0.05) (Math.Add .t0) (Math.Cos) >= .u0
  .t1 (Math.Cos) (Math.Subtract .t2) (Math.Cos) (Math.Add .t1) (Math.Multiply 0.2) (Math.Negate) (Math.Sin) >= .u1
  .u1 (Math.Add .t3) (Math.Add .time) (Math.Add .u0) (Do ucos))

(defshards shader-main []
  (Shader.ReadBuffer :Name "viewport" :BufferName "view") >= .viewport
  (Shader.ReadInput "texCoord0") >= .uv
  (Shader.ReadBuffer "time") >== .time
  (Shader.ReadGlobal "color") >= .base-color

  .uv (Do plasma) >= .vcolor
  .vcolor  (Do palette-f) >= .sheen-color

  .sheen-color (ToFloat4) (Math.Add (Float4 0.0 0.0 0.0 1.0)) (Shader.WriteGlobal "color"))

(defwire update-cube-transform
  (Float3 0.25) (Math.Scaling) >= .transform
  .time (Math.Cos) (Math.Multiply 10.0) (Math.DegreesToRadians) (Math.AxisAngleZ) (Math.Rotation) >= .rmat-0
  .time (Math.Multiply 0.8) (Math.Cos) (Math.Multiply 3.0) (Math.DegreesToRadians) (Math.AxisAngleY) (Math.Rotation) >= .rmat-1
  .rmat-1 (Math.MatMul .rmat-0) (Math.MatMul .transform) > .transform)

(defloop gfx
  (Setup
   0.0 >= .time
   .time (Broadcast "time")

   {:Position (Float3 0.0 1.0 0.0) :Target (Float3 0.0)} (Math.LookAt) = .view-transform
   (GFX.View .view-transform) >= .view

   (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) >= .cube

   (Float3 0.0) (Math.Translation) >= .transform
   (Do update-cube-transform)
   {:Mesh .cube} (GFX.Drawable :Transform .transform) >= .drawable

   (GFX.BuiltinFeature :Id BuiltinFeatureId.Transform) >> .features
   (GFX.BuiltinFeature :Id BuiltinFeatureId.BaseColor) >> .features
   {:Shaders [{:Stage ProgrammableGraphicsStage.Fragment
               :After ["readColor"]
               :Before ["writeColor"]
               :EntryPoint (-> (shader-main))}]} (GFX.Feature
                                                  :ViewGenerators
                                                  (->
                                                   (Listen "time") >= .time
                                                   {:time .time})) >> .features
   {:Features .features} (GFX.DrawablePass) >> .render-steps)

  .time (Math.Add timestep) > .time
  .time (Broadcast "time")
  (Do update-cube-transform)

  .drawable (GFX.Draw)
  (GFX.Render :Steps .render-steps :View .view))

(defmesh root)
(schedule root (Wire "test-wire" :Looped :LStack
                     (GFX.MainWindow :Title "SDL Window" :Width 1280 :Height 720 :Debug false :Contents
                                     (Step gfx))))
(if (run root timestep 200) nil (throw "Root tick failed"))
