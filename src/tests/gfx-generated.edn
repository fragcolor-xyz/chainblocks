(def BlendOverwrite {:Operation BlendOperation.Add :Src BlendFactor.One :Dst BlendFactor.Zero})

(defloop generator
  (| (Take "Queue") >= .parent-queue)
  (| (Take "View") >= .parent-view)
  (Once :Every 0.01 :Action
        (->
         (GFX.BuiltinFeature :Id BuiltinFeatureId.Transform) >> .features
         (GFX.BuiltinFeature :Id BuiltinFeatureId.BaseColor) >> .features
         {:State {:Blend {:Color BlendOverwrite :Alpha BlendOverwrite}}
          :Shaders
          [{:Stage ProgrammableGraphicsStage.Fragment
            :EntryPoint
            (->
             (Shader.ReadGlobal "color") >= .scene-color
             .scene-color
             (| (Take 0) >= .r) (| (Take 1) >= .g) (| (Take 2) >= .b)
             (Float4 .g .g .g 1.0)
             (Math.Add (Float4 0.2 0.2 0.2 0.0))
             (Shader.WriteOutput "otherColor"))
            :After ["writeColor"]}]}
         (GFX.Feature) >> .features
         {:Outputs [{:Name "otherColor" :Format TextureFormat.RGBA8Unorm} {:Name "depth"}]
          :Features .features :Queue .parent-queue} (GFX.DrawablePass) >> .steps

         (GFX.Texture :Format TextureFormat.RGBA8Unorm) >= .out-texture
         (GFX.RenderInto :Textures {:otherColor .out-texture}
                         :Contents (->
                                    (GFX.Render :View .parent-view :Steps .steps)))))
  ; Returned parameters from rendered texture above
  {:someTexture .out-texture})

(defwire create-test-feature
  {:State {:Blend {:Color BlendOverwrite :Alpha BlendOverwrite}}
   :Shaders
   [{:Stage ProgrammableGraphicsStage.Fragment
     :EntryPoint
     (->
      (Shader.SampleTexture "someTexture") (Shader.WriteGlobal "color"))
     :Before ["writeColor"]}]} (GFX.Feature
                                :ViewGenerators generator))

(def timestep (/ 1.0 120.0))

(defmesh root)
(defloop content
  (Setup
   0.0 >= .time)
  .time (Math.Add timestep) > .time

  (Setup
   {:Position (Float3 -1.0 1.5 20.0) :Target (Float3 0.0)} (Math.LookAt) >= .view-transform
   (GFX.View .view-transform) >= .view

   (Float3 0.0) (Math.Translation) >= .transform
   -90.0 (Math.DegreesToRadians) (Math.AxisAngleX) (Math.Rotation) >= .tmp-rot
   (Float3 30.0 30.0 1.0) (Math.Scaling) >= .tmp-scale
   .transform (Math.MatMul .tmp-rot) (Math.MatMul .tmp-scale) >= .plane-transform

   (Float3 0.0 0.5 0.0) (Math.Translation) > .transform
   45.0 (Math.DegreesToRadians) (Math.AxisAngleY) (Math.Rotation) > .tmp-rot
   (Float3 1.0 1.0 1.0) (Math.Scaling) > .tmp-scale
   .transform (Math.MatMul .tmp-rot) (Math.MatMul .tmp-scale) >= .cube-transform

   (GFX.BuiltinMesh :Type BuiltinMeshType.Plane) >= .plane-mesh
   {:Mesh .plane-mesh :Params {:baseColor (Float4 0.4 0.4 0.94 1.0)}} (GFX.Drawable :Transform .plane-transform) >> .drawables

   (GFX.BuiltinMesh :Type BuiltinMeshType.Cube) >= .cube-mesh
   {:Mesh .cube-mesh :Params {:baseColor (Float4 0.12 0.7 0.2 1.0)}} (GFX.Drawable :Transform .cube-transform) >> .drawables

   (GFX.BuiltinFeature :Id BuiltinFeatureId.Transform) >> .features
   (GFX.BuiltinFeature :Id BuiltinFeatureId.BaseColor) >> .features
   (Do create-test-feature) >> .features

   {:Features .features} (GFX.DrawablePass) >> .render-steps)

  ; Update view transform
  .view-transform (FreeCamera :FlySpeed 10.0) > .view-transform

  .drawables (GFX.Draw)
  (GFX.Render :Steps .render-steps :View .view))

(schedule root
          (Wire "main-loop-wire" :Looped :LStack
                (GFX.MainWindow :Title "Test" :Width 1280 :Height 720 :IgnoreCompilationErrors true :Contents (Step content))))
(run root timestep)
