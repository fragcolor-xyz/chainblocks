; NOTE: This shader is converted from https://www.shadertoy.com/view/tlVGDt
; With slight modifications

(def timestep (/ 1.0 120.0))

; Special modulo since % is negative for negatives
(defshards mod-positive [div]
  (| (Math.Divide div) (Math.Floor) (Math.Multiply div) >= .mod-wholes)
  (Math.Subtract .mod-wholes))

(defpure rot
  >= .input
  .input (Math.Cos) >= .c
  .input (Math.Sin)
  (| >= .s)
  (| (Math.Negate) >= .neg-s)
  (Float2 .c .s) >> .result
  (Float2 .neg-s .c) >> .result
  .result)

(defwire box-sdf-base
  .box-pos (Math.Abs) (Math.Subtract .box-base) >= .q
  .q (| (Take 0) >= .q-x) (| (Take 1) >= .q-y) (| (Take 2) >= .q-z)
  .q-x (Max .q-y) (Max .q-z) (Min 0.0) >= .tmp
  .q (Max (Float3 0.0)) (Math.Length) (Math.Add .tmp))

(defwire box-sdf
  .pos (Math.Multiply .scale) >= .box-pos
  (Float3 0.4 0.4 0.1) >= .box-base
  (Do box-sdf-base) (Math.Divide 1.5) (Math.Negate))

(defn  box-elem [ops]
  (->
   .pos-orig > .pos
   .pos (| (Take 0) > .x) (| (Take 1) > .y)   (| (Take 2) > .z)
   .gtime (Math.Multiply 0.4) (Math.Sin) (Math.Multiply 2.5) ~ops
   (Float2 .x .y) > .tmp-2
   0.8 (Do rot) (Math.MatMul .tmp-2)
   (| (Take 0) > .x) (| (Take 1) > .y) (Float3 .x .y .z) > .pos

   .gtime (Math.Multiply 0.4) (Math.Sin) (Math.Abs) (Math.Multiply 1.5) > .scale
   2.0 (Math.Subtract .scale) > .scale

   (Do box-sdf)))

(defwire distance-field
  .pos = .pos-orig
  0.0 >= .x >= .y >= .z
  (Float2 0) >= .tmp-2
  0.0 >= .scale

  (box-elem [(Math.Add .y) > .y]) >= .box-1
  (box-elem [(Math.Subtract .y) > .y]) >= .box-2
  (box-elem [(Math.Add .x) > .x]) >= .box-3
  (box-elem [(Math.Subtract .x) > .x]) >= .box-4

  .box-1 (Max .box-2) (Max .box-3) (Max .box-4))

(defshards shader-main []
  (Shader.ReadBuffer :Name "viewport" :BufferName "view") >= .viewport
  (Shader.ReadInput "texCoord0") >= .uv
  (Shader.ReadBuffer "time") >= .time

  ; Convert uv to screen position & aspect correct normalize 
  .viewport (Take [2 3]) >= .screen-size
  (Math.Multiply .uv) >= .screen-pos
  .screen-size (Take 0) >= .screen-w
  .screen-size (Take 1) >= .screen-h
  .screen-w (Min .screen-h) >= .screen-min-dim
  .screen-pos (Math.Multiply 2.0) (Math.Subtract .screen-size) (Math.Divide .screen-min-dim) (Math.Multiply (Float2 1.0 -1.0)) = .uv1

  ; Compute ray
  .time (Math.Multiply 4.0) >= .z
  (Float3 0.0 -0.2 .z) >= .ro
  .uv1  (| (Take 0) >= .x) (| (Take 1) >= .y)
  (Float3 .x .y 1.5) (Math.Normalize) >= .ray

  .ray (| (Take 0) > .x) (| (Take 1) > .y) (| (Take 2) > .z)

  ; Rotate ray
  (Float2 .x .y) >= .tmp-2
  .time (Math.Multiply 0.03) (Math.Sin) (Math.Multiply 5.0) (Do rot) (Math.MatMul .tmp-2) > .tmp-2
  .tmp-2 (Take 0) > .x
  .tmp-2 (Take 1) > .y
  (Float2 .y .z) > .tmp-2
  .time (Math.Multiply 0.05) (Math.Sin) (Math.Multiply 0.2) (Do rot) (Math.MatMul .tmp-2) > .tmp-2
  .tmp-2 (Take 0) > .y
  .tmp-2 (Take 1) > .z

  (Float3 .x .y .z) > .ray

  0.1 >= .t
  (Float3 0.0) >= .col
  0.0 >= .ac
  0.0 >= .d

  (ForRange 0 99 (->
                  = .i
                  .ray (Math.Multiply .t) (Math.Add .ro) >= .pos
                  (Math.Subtract 2.0) (mod-positive 4.0) (Math.Subtract 2.0) > .pos

                  .i (ToFloat) (Math.Multiply 0.01) >= .tmp
                  .time (Math.Subtract .tmp) >== .gtime

                  (Do distance-field)
                  (Math.Abs) (Max 0.01) > .d

                  .d (Math.Negate) (Math.Multiply 23.0) (Math.Exp)
                  (Math.Add .ac) > .ac

                  .d (Math.Multiply 0.55) (Math.Add .t) > .t))

  (Float3 .ac) (Math.Multiply 0.02) > .col
  .time (Math.Sin) (Math.Abs) (Math.Multiply 0.2) > .y
  .time (Math.Sin) (Math.Multiply 0.2) (Math.Add 0.5) > .z
  (Float3 0.0 .y .z) (Math.Add .col) > .col

  .time (Math.Sin) (Math.Multiply 0.02) (Math.Add 0.02) >= .a
  1.0 (Math.Subtract .a) > .a

  .col (| (Take 0) > .x) (| (Take 1) > .y) (| (Take 2) > .z)
  (Float4 .x .y .z 1.0) (Shader.WriteOutput "color")
  ; End shader
  )

(defloop gfx
  (Setup
   0.0 >= .time
   .time (Broadcast "time")

   {} (GFX.Feature :ViewGenerators
                   (->
                    (Listen "time") >= .time
                    {:time .time})) >> .features
   {:EntryPoint (-> (shader-main)) :Features .features} (GFX.EffectPass) >> .render-steps)

  (GFX.Render :Steps .render-steps)

  .time (Math.Add timestep) > .time
  .time (Broadcast "time"))

(defmesh root)
(schedule root (Wire "main-loop-wire" :Looped :LStack
                     (GFX.MainWindow :Title "SDL Window" :Width 1280 :Height 720 :Debug false :Contents
                                     (Step gfx))))
(if (run root timestep 100) nil (throw "Root tick failed"))
