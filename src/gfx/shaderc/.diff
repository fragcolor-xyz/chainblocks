Only in .: .diff
Only in .: api.hpp
Only in .: CMakeLists.txt
diff -U5 ../../../deps/bgfx/tools/shaderc/shaderc.cpp ./shaderc.cpp
--- ../../../deps/bgfx/tools/shaderc/shaderc.cpp	2021-11-16 17:32:38.847555500 +0100
+++ ./shaderc.cpp	2021-11-17 17:31:13.563604600 +0100
@@ -4,10 +4,11 @@
  */
 
 #include "shaderc.h"
 #include <bx/commandline.h>
 #include <bx/filepath.h>
+#include <cassert>
 
 #define MAX_TAGS 256
 extern "C"
 {
 #include <fpp.h>
@@ -19,12 +20,35 @@
 #define BGFX_CHUNK_MAGIC_VSH BX_MAKEFOURCC('V', 'S', 'H', BGFX_SHADER_BIN_VERSION)
 
 #define BGFX_SHADERC_VERSION_MAJOR 1
 #define BGFX_SHADERC_VERSION_MINOR 18
 
-namespace bgfx
-{
+namespace bgfx {
+#ifdef SHADERC_STANDALONE
+	static bx::DefaultAllocator s_allocator;
+	bx::AllocatorI* g_allocator = &s_allocator;
+
+	struct TinyStlAllocator
+	{
+		static void* static_allocate(size_t _bytes);
+		static void static_deallocate(void* _ptr, size_t /*_bytes*/);
+	};
+
+	void* TinyStlAllocator::static_allocate(size_t _bytes)
+	{
+		return BX_ALLOC(g_allocator, _bytes);
+	}
+
+	void TinyStlAllocator::static_deallocate(void* _ptr, size_t /*_bytes*/)
+	{
+		if (NULL != _ptr)
+		{
+			BX_FREE(g_allocator, _ptr);
+		}
+	}
+#endif
+
 	bool g_verbose = false;
 
 	struct ShadingLang
 	{
 		enum Enum
@@ -269,19 +293,19 @@
 		"uvec3",
 		"uvec4",
 		NULL
 	};
 
-	const char* s_uniformTypeName[] =
+	const char* s_uniformTypeName1[] =
 	{
 		"int",  "int",
 		NULL,   NULL,
 		"vec4", "float4",
 		"mat3", "float3x3",
 		"mat4", "float4x4",
 	};
-	BX_STATIC_ASSERT(BX_COUNTOF(s_uniformTypeName) == UniformType::Count*2);
+	BX_STATIC_ASSERT(BX_COUNTOF(s_uniformTypeName1) == UniformType::Count*2);
 
 	static const char* s_allowedVertexShaderInputs[] =
 	{
 		"a_position",
 		"a_normal",
@@ -400,27 +424,27 @@
 		}
 
 		return _glsl; // centroid, noperspective
 	}
 
-	const char* getUniformTypeName(UniformType::Enum _enum)
+	const char* getUniformTypeName1(UniformType::Enum _enum)
 	{
 		uint32_t idx = _enum & ~(kUniformFragmentBit|kUniformSamplerBit);
 		if (idx < UniformType::Count)
 		{
-			return s_uniformTypeName[idx];
+			return s_uniformTypeName1[idx];
 		}
 
 		return "Unknown uniform type?!";
 	}
 
-	UniformType::Enum nameToUniformTypeEnum(const char* _name)
+	UniformType::Enum nameToUniformTypeEnum1(const char* _name)
 	{
 		for (uint32_t ii = 0; ii < UniformType::Count*2; ++ii)
 		{
-			if (NULL != s_uniformTypeName[ii]
-			&&  0 == bx::strCmp(_name, s_uniformTypeName[ii]) )
+			if (NULL != s_uniformTypeName1[ii]
+			&&  0 == bx::strCmp(_name, s_uniformTypeName1[ii]) )
 			{
 				return UniformType::Enum(ii/2);
 			}
 		}
 
@@ -1459,37 +1483,53 @@
 			bx::write(_writer, outputHash);
 		}
 
 		if (raw)
 		{
-			if (profile->lang == ShadingLang::GLSL)
+			if(false) {
+			}
+#ifdef SHADERC_GLSL
+			else if (profile->lang == ShadingLang::GLSL)
 			{
 				bx::write(_writer, uint16_t(0) );
 
 				uint32_t shaderSize = (uint32_t)bx::strLen(input);
 				bx::write(_writer, shaderSize);
 				bx::write(_writer, input, shaderSize);
 				bx::write(_writer, uint8_t(0) );
 
 				compiled = true;
 			}
-			else if (profile->lang == ShadingLang::Metal)
-			{
-				compiled = compileMetalShader(_options, BX_MAKEFOURCC('M', 'T', 'L', 0), input, _writer);
+#endif 
+#ifdef SHADERC_METAL
+			else if (profile->lang == ShadingLang::Metal) {
+				
+				compiled = compileMetalShader(
+					_options, BX_MAKEFOURCC('M', 'T', 'L', 0), input, _writer);
 			}
+#endif
+#ifdef SHADERC_SPIRV
 			else if (profile->lang == ShadingLang::SpirV)
 			{
 				compiled = compileSPIRVShader(_options, profile->id, input, _writer);
 			}
+#endif
+#ifdef SHADERC_PSSL
 			else if (profile->lang == ShadingLang::PSSL)
 			{
 				compiled = compilePSSLShader(_options, 0, input, _writer);
 			}
-			else
+#endif
+#ifdef SHADERC_HLSL
+			else if (profile->lang == ShadingLang::HLSL)
 			{
 				compiled = compileHLSLShader(_options, profile->id, input, _writer);
 			}
+#endif
+			else {
+				assert(false && "Shader type not supported");
+			}
 		}
 		else if ('c' == _options.shaderType) // Compute
 		{
 			bx::StringView entry = bx::strFind(input, "void main()");
 			if (entry.isEmpty() )
@@ -1504,11 +1544,13 @@
 				}
 				else
 				{
 					if (profile->lang != ShadingLang::PSSL)
 					{
+#ifdef SHADERC_PSSL
 						preprocessor.writef(getPsslPreamble() );
+#endif
 					}
 
 					preprocessor.writef(
 						"#define lowp\n"
 						"#define mediump\n"
@@ -1629,26 +1671,38 @@
 						else
 						{
 							code += _comment;
 							code += preprocessor.m_preprocessed;
 
-							if (profile->lang == ShadingLang::Metal)
-							{
+							if(false) {
+							}
+#ifdef SHADERC_METAL
+							else if (profile->lang == ShadingLang::Metal) {
 								compiled = compileMetalShader(_options, BX_MAKEFOURCC('M', 'T', 'L', 0), code, _writer);
 							}
+#endif
+#ifdef SHADERC_SPIRV
 							else if (profile->lang == ShadingLang::SpirV)
 							{
 								compiled = compileSPIRVShader(_options, profile->id, code, _writer);
 							}
+#endif
+#ifdef SHADERC_PSSL
 							else if (profile->lang == ShadingLang::PSSL)
 							{
 								compiled = compilePSSLShader(_options, 0, code, _writer);
 							}
-							else
+#endif
+#ifdef SHADERC_HLSL
+							else if (profile->lang == ShadingLang::HLSL)
 							{
 								compiled = compileHLSLShader(_options, profile->id, code, _writer);
 							}
+#endif
+							else {
+								assert(false && "Shader type not supported");
+							}
 						}
 					}
 
 					if (compiled)
 					{
@@ -1764,11 +1818,13 @@
 				}
 				else
 				{
 					if (profile->lang == ShadingLang::PSSL)
 					{
+#if SHADERC_PSSL
 						preprocessor.writef(getPsslPreamble() );
+#endif
 					}
 
 					preprocessor.writef(
 						"#define lowp\n"
 						"#define mediump\n"
@@ -2500,35 +2556,49 @@
 
 								if (profile->lang == ShadingLang::ESSL)
 								{
 									glsl_profile |= 0x80000000;
 								}
-
+#ifdef SHADERC_GLSL
 								compiled = compileGLSLShader(_options, glsl_profile, code, _writer);
+#else
+								assert(false && "Shader type not supported");
+#endif
 							}
 						}
 						else
 						{
 							code += _comment;
 							code += preprocessor.m_preprocessed;
 
-							if (profile->lang == ShadingLang::Metal)
-							{
-								compiled = compileMetalShader(_options, BX_MAKEFOURCC('M', 'T', 'L', 0), code, _writer);
+							if(false) {
+							}
+#ifdef SHADERC_METAL
+							else if (profile->lang == ShadingLang::Metal) {
+								
+								compiled = compileMetalShader(
+									_options, BX_MAKEFOURCC('M', 'T', 'L', 0), code, _writer);
 							}
+#endif
+#ifdef SHADERC_SPIRV
 							else if (profile->lang == ShadingLang::SpirV)
 							{
 								compiled = compileSPIRVShader(_options, profile->id, code, _writer);
 							}
+#endif
+#ifdef SHADERC_PSSL
 							else if (profile->lang == ShadingLang::PSSL)
 							{
 								compiled = compilePSSLShader(_options, 0, code, _writer);
 							}
-							else
+#endif
+#ifdef SHADERC_HLSL
+							else if (profile->lang == ShadingLang::HLSL)
 							{
 								compiled = compileHLSLShader(_options, profile->id, code, _writer);
 							}
+#endif
 						}
 					}
 
 					if (compiled)
 					{
@@ -2798,9 +2868,11 @@
 		return bx::kExitFailure;
 	}
 
 } // namespace bgfx
 
+#ifdef SHADERC_STANDALONE
 int main(int _argc, const char* _argv[])
 {
 	return bgfx::compileShader(_argc, _argv);
 }
+#endif
diff -U5 ../../../deps/bgfx/tools/shaderc/shaderc.h ./shaderc.h
--- ../../../deps/bgfx/tools/shaderc/shaderc.h	2021-11-16 14:41:29.205132000 +0100
+++ ./shaderc.h	2021-11-17 17:20:02.014105900 +0100
@@ -60,12 +60,18 @@
 #include <bx/string.h>
 #include <bx/hash.h>
 #include <bx/file.h>
 #include "../../src/vertexlayout.h"
 
-namespace bgfx
-{
+namespace bgfx {
+	extern bx::AllocatorI* g_allocator;
+	struct TinyStlAllocator
+	{
+		static void* static_allocate(size_t _bytes);
+		static void static_deallocate(void* _ptr, size_t /*_bytes*/);
+	};
+	
 	extern bool g_verbose;
 
 	bx::StringView nextWord(bx::StringView& _parse);
 
 	constexpr uint8_t kUniformFragmentBit  = 0x10;
@@ -77,12 +83,12 @@
 		| kUniformSamplerBit
 		| kUniformReadOnlyBit
 		| kUniformCompareBit
 		;
 
-	const char* getUniformTypeName(UniformType::Enum _enum);
-	UniformType::Enum nameToUniformTypeEnum(const char* _name);
+	const char* getUniformTypeName1(UniformType::Enum _enum);
+	UniformType::Enum nameToUniformTypeEnum1(const char* _name);
 
 	struct Uniform
 	{
 		Uniform()
 			: type(UniformType::Count)
diff -U5 ../../../deps/bgfx/tools/shaderc/shaderc_glsl.cpp ./shaderc_glsl.cpp
--- ../../../deps/bgfx/tools/shaderc/shaderc_glsl.cpp	2021-08-05 14:31:03.077527000 +0200
+++ ./shaderc_glsl.cpp	2021-11-17 17:18:05.887000000 +0100
@@ -191,11 +191,11 @@
 						bx::fromString(&tmp, parse);
 						num = uint8_t(tmp);
 					}
 
 					Uniform un;
-					un.type = nameToUniformTypeEnum(uniformType);
+					un.type = nameToUniformTypeEnum1(uniformType);
 
 					if (UniformType::Count != un.type)
 					{
 						un.name.assign(name.getPtr(), name.getTerm());
 
@@ -256,11 +256,11 @@
 					{
 						bx::strCopy(uniformName, int32_t(eol.getPtr()-name+1), name);
 					}
 
 					Uniform un;
-					un.type = nameToUniformTypeEnum(uniformType);
+					un.type = nameToUniformTypeEnum1(uniformType);
 
 					if (UniformType::Count != un.type)
 					{
 						BX_TRACE("name: %s (type %d, num %d)", uniformName, un.type, num);
 
@@ -292,11 +292,11 @@
 				const bx::StringView textureName = bx::strFind(parse, textureNameMark);
 
 				if (!textureName.isEmpty())
 				{
 					Uniform un;
-					un.type = nameToUniformTypeEnum("int");	// int for sampler
+					un.type = nameToUniformTypeEnum1("int");	// int for sampler
 					const char* varNameEnd = textureName.getPtr() - 1;
 					parse.set(parse.getPtr(), varNameEnd - 1);
 					const char* varNameBeg = parse.getPtr();
 					for (int ii = parse.getLength() - 1; 0 <= ii; --ii)
 					{
@@ -348,11 +348,11 @@
 			bx::write(_writer, un.texDimension);
 			bx::write(_writer, un.texFormat);
 
 			BX_TRACE("%s, %s, %d, %d, %d"
 				, un.name.c_str()
-				, getUniformTypeName(un.type)
+				, getUniformTypeName1(un.type)
 				, un.num
 				, un.regIndex
 				, un.regCount
 				);
 		}
diff -U5 ../../../deps/bgfx/tools/shaderc/shaderc_hlsl.cpp ./shaderc_hlsl.cpp
--- ../../../deps/bgfx/tools/shaderc/shaderc_hlsl.cpp	2021-08-05 14:31:03.078530800 +0200
+++ ./shaderc_hlsl.cpp	2021-11-17 17:18:06.040000000 +0100
@@ -749,11 +749,11 @@
 				bx::write(_writer, un.texDimension);
 				bx::write(_writer, un.texFormat);
 
 				BX_TRACE("%s, %s, %d, %d, %d"
 					, un.name.c_str()
-					, getUniformTypeName(un.type)
+					, getUniformTypeName1(un.type)
 					, un.num
 					, un.regIndex
 					, un.regCount
 					);
 			}
diff -U5 ../../../deps/bgfx/tools/shaderc/shaderc_metal.cpp ./shaderc_metal.cpp
--- ../../../deps/bgfx/tools/shaderc/shaderc_metal.cpp	2021-08-05 14:31:03.080535300 +0200
+++ ./shaderc_metal.cpp	2021-11-17 17:23:52.240107000 +0100
@@ -21,20 +21,10 @@
 #include <spirv_msl.hpp>
 #include <spirv_reflect.hpp>
 #include <spirv-tools/optimizer.hpp>
 BX_PRAGMA_DIAGNOSTIC_POP()
 
-namespace bgfx
-{
-	struct TinyStlAllocator
-	{
-		static void* static_allocate(size_t _bytes);
-		static void static_deallocate(void* _ptr, size_t /*_bytes*/);
-	};
-
-} // namespace bgfx
-
 #define TINYSTL_ALLOCATOR bgfx::TinyStlAllocator
 #include <tinystl/allocator.h>
 #include <tinystl/string.h>
 #include <tinystl/unordered_map.h>
 #include <tinystl/vector.h>
@@ -241,11 +231,11 @@
 			bx::write(_writer, un.texDimension);
 			bx::write(_writer, un.texFormat);
 
 			BX_TRACE("%s, %s, %d, %d, %d"
 				, un.name.c_str()
-				, getUniformTypeName(un.type)
+				, getUniformTypeName1(un.type)
 				, un.num
 				, un.regIndex
 				, un.regCount
 			);
 		}
Only in .: shaderc_module.cpp
diff -U5 ../../../deps/bgfx/tools/shaderc/shaderc_spirv.cpp ./shaderc_spirv.cpp
--- ../../../deps/bgfx/tools/shaderc/shaderc_spirv.cpp	2021-11-17 17:06:23.848106500 +0100
+++ ./shaderc_spirv.cpp	2021-11-17 17:22:59.470105800 +0100
@@ -22,34 +22,11 @@
 #include <spirv_msl.hpp>
 #include <spirv_reflect.hpp>
 #include <spirv-tools/optimizer.hpp>
 BX_PRAGMA_DIAGNOSTIC_POP()
 
-namespace bgfx
-{
-	static bx::DefaultAllocator s_allocator;
-	bx::AllocatorI* g_allocator = &s_allocator;
-
-	struct TinyStlAllocator
-	{
-		static void* static_allocate(size_t _bytes);
-		static void static_deallocate(void* _ptr, size_t /*_bytes*/);
-	};
 
-	void* TinyStlAllocator::static_allocate(size_t _bytes)
-	{
-		return BX_ALLOC(g_allocator, _bytes);
-	}
-
-	void TinyStlAllocator::static_deallocate(void* _ptr, size_t /*_bytes*/)
-	{
-		if (NULL != _ptr)
-		{
-			BX_FREE(g_allocator, _ptr);
-		}
-	}
-} // namespace bgfx
 
 #define TINYSTL_ALLOCATOR bgfx::TinyStlAllocator
 #include <tinystl/allocator.h>
 #include <tinystl/string.h>
 #include <tinystl/unordered_map.h>
@@ -351,11 +328,11 @@
 			bx::write(_writer, un.texDimension);
 			bx::write(_writer, un.texFormat);
 
 			BX_TRACE("%s, %s, %d, %d, %d"
 				, un.name.c_str()
-				, getUniformTypeName(un.type)
+				, getUniformTypeName1(un.type)
 				, un.num
 				, un.regIndex
 				, un.regCount
 				);
 		}
