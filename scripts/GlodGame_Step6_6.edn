(defshards Innitialize_Character []
  (LoadImage "GlodImages/Character1.png") = .Character_Image
  (LoadImage "GlodImages/Character1_Left.png") = .Character_Left
  (LoadImage "GlodImages/Character1_Right.png") = .Character_Right
  (LoadImage "GlodImages/Character1_Jumping_Right.png") = .Character_Jumping_Right
  (LoadImage "GlodImages/Character1_Jumping_Left.png") = .Character_Jumping_Left

  ;; --------- Idle Sprites (Facing Left) -------------
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png") = .image_idle_Left_1
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png") = .image_idle_Left_2
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png") = .image_idle_Left_3
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png") = .image_idle_Left_4
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png") = .image_idle_Left_5
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png") = .image_idle_Left_6
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png") = .image_idle_Left_7
  [.image_idle_Left_1 .image_idle_Left_2 .image_idle_Left_3 .image_idle_Left_4 .image_idle_Left_5
   .image_idle_Left_6 .image_idle_Left_7] >= .idle_Left_image_array

  ;; ---------- Idle Sprites (Facing Right) ----------------
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png") = .image_idle_Right_1
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png") = .image_idle_Right_2
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png") = .image_idle_Right_3
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png") = .image_idle_Right_4
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png") = .image_idle_Right_5
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png") = .image_idle_Right_6
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png") = .image_idle_Right_7
  [.image_idle_Right_1 .image_idle_Right_2 .image_idle_Right_3 .image_idle_Right_4 .image_idle_Right_5
   .image_idle_Right_6 .image_idle_Right_7] >= .idle_Right_image_array

  (Count .idle_Left_image_array) (Math.Subtract 1) >= .idle_image_index_max
  0 >= .idle_image_index
  0.08 >= .idle_animation_speed


  ;; ----------- Walking Sprites (Facing Right) ---------------
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_1.png") = .image_walking_Right_1
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_2.png") = .image_walking_Right_2
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_3.png") = .image_walking_Right_3
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_4.png") = .image_walking_Right_4
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_5.png") = .image_walking_Right_5
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_6.png") = .image_walking_Right_6
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_Right_7.png") = .image_walking_Right_7
  [.image_walking_Right_1 .image_walking_Right_2 .image_walking_Right_3 .image_walking_Right_4 .image_walking_Right_5
   .image_walking_Right_6 .image_walking_Right_7] >= .walking_Right_image_array

  ;; -------------- Walking Sprites (Facing Left) -----------------
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png") = .image_walking_Left_1
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png") = .image_walking_Left_2
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png") = .image_walking_Left_3
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png") = .image_walking_Left_4
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png") = .image_walking_Left_5
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png") = .image_walking_Left_6
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png") = .image_walking_Left_7
  [.image_walking_Left_1 .image_walking_Left_2 .image_walking_Left_3 .image_walking_Left_4
   .image_walking_Left_5 .image_walking_Left_6 .image_walking_Left_7] >= .walking_Left_image_array

  (Count .walking_Left_image_array) (Math.Subtract 1) >= .walking_image_index_max
  0 >= .walking_image_index
  0.08 >= .Walking_Animation_Speed ;; Reduce number to increase animation speed


  true >= .CharacterIdle
  false >= .Character_Jump
  false >= .Character_Walking_Left
  false >= .Character_Walking_Right
  1 >= .Character_Direction

  false >= .IsMoving
  false >= .IsJumping

  0.0 >= .X
  620.0 >= .Y
  (float2 .X .Y) >= .Character_Position

  0.0 >= .Character_X_Velocity
  0.0 >= .Character_Y_Velocity
  0.0 >= .Character_Y_Acceleration)

(defshards Button_Inputs []

  ;; ----------- Left Right Inputs for Walking ------------
  (Inputs.KeyDown
   :Key "left"
   :Action (->
            -1 > .Character_Direction
            true > .Character_Walking_Left
            false > .Character_Walking_Right
            false > .CharacterIdle
            false > .Character_Jump
            true > .IsMoving
            -5.0 > .Character_X_Velocity))

  (Inputs.KeyDown
   :Key "right"
   :Action (->
            1 > .Character_Direction
            false > .Character_Walking_Left
            true > .Character_Walking_Right
            false > .CharacterIdle
            false > .Character_Jump
            true > .IsMoving
            5.0 > .Character_X_Velocity))

  (Inputs.KeyUp
   :Key "left"
   :Action (->
            false > .Character_Walking_Left
            false > .Character_Walking_Right
            true > .CharacterIdle
            false > .Character_Jump
            false > .IsMoving
            0.0 > .Character_X_Velocity))

  (Inputs.KeyUp
   :Key "right"
   :Action (->
            false > .Character_Walking_Left
            false > .Character_Walking_Right
            true > .CharacterIdle
            false > .Character_Jump
            false > .IsMoving
            0.0 > .Character_X_Velocity))

  ;; ------------------- Up Input for Jumping ---------------
  (Inputs.KeyDown
   :Key "up"
   :Action (->
            .IsJumping
            (If :Predicate (Is false)
                :Then (->
                       false > .Character_Walking_Left
                       false > .Character_Walking_Right
                       false > .CharacterIdle
                       true > .Character_Jump
                       -20.0 > .Character_Y_Velocity
                       1.0 >  .Character_Y_Acceleration
                       true > .IsJumping)))))

;; ----------- Idle_Animation ------------

(defloop Idle_Animation_Left
  .idle_image_index (Math.Add 1)
  > .idle_image_index
  (When :Predicate (IsMore .idle_image_index_max)
        :Action (-> 0 > .idle_image_index))
  (Pause .idle_animation_speed))

(defloop Walking_Animation
  .walking_image_index (Math.Add 1)
  > .walking_image_index
  (When :Predicate (IsMore .walking_image_index_max)
        :Action (-> 0 > .walking_image_index))
  (Pause .Walking_Animation_Speed))

;; ----------- Running Logic ---------------
(defshards Run_Logic []
  .X (Math.Add .Character_X_Velocity)
  > .X

  (float2 .X .Y) > .Character_Position)

;; ------------ Gravity Logic ---------------
(defshards Gravity_Logic []
  .Y (Math.Add .Character_Y_Velocity)
  > .Y

  .Character_Y_Velocity (Math.Add .Character_Y_Acceleration)
  > .Character_Y_Velocity

  (float2 .X .Y) > .Character_Position)

;; ---------- Character_Boundary ------------

(defshards Character_Boundary []
  .X
  (When :Predicate (IsMore 600.0)
        :Action (->
                 600.0 > .X))

  .X
  (When :Predicate (IsLess -600.0)
        :Action (->
                 -600.0 > .X))
  .Y
  (When :Predicate (IsMore 620.0)
        :Action (-> 620.0 > .Y
                    0.0 > .Character_Y_Velocity
                    0.0 > .Character_Y_Acceleration
                    false > .IsJumping

                    .IsMoving
                    (If :Predicate (Is false)
                        :Then (->
                               false > .Character_Walking_Left
                               false > .Character_Walking_Right
                               true > .CharacterIdle
                               false > .Character_Jump))
                    .IsMoving
                    (If :Predicate (-> (Is true)
                                       (And)
                                       .Character_Direction (Is 1))
                        :Then (->
                               false > .Character_Walking_Left
                               true > .Character_Walking_Right
                               false > .CharacterIdle
                               false > .Character_Jump))

                    .IsMoving
                    (If :Predicate (-> (Is true)
                                       (And)
                                       .Character_Direction (Is -1))
                        :Then (->
                               true > .Character_Walking_Left
                               false > .Character_Walking_Right
                               false > .CharacterIdle
                               false > .Character_Jump)))))

;; ------------ Coins ------------------
;; -------------------------------------
;; ------------ Innitialize_Coin ---------------
(defshards Innitialize_Coin []
  (LoadImage "GlodImages/Coin/Coin_1.png") = .Coin_1
  (LoadImage "GlodImages/Coin/Coin_2.png") = .Coin_2
  (LoadImage "GlodImages/Coin/Coin_3.png") = .Coin_3
  (LoadImage "GlodImages/Coin/Coin_4.png") = .Coin_4
  (LoadImage "GlodImages/Coin/Coin_5.png") = .Coin_5
  (LoadImage "GlodImages/Coin/Coin_6.png") = .Coin_6
  (LoadImage "GlodImages/Coin/Coin_7.png") = .Coin_7
  [.Coin_1 .Coin_2 .Coin_3 .Coin_4 .Coin_5 .Coin_6 .Coin_7] >= .coin_image_array
  (Count .coin_image_array) (Math.Subtract 1) >= .coin_image_index_max
  0 >= .coin_image_index
  0.1 >= .coin_Animation_Speed

  ;; ----- Coin 1----
  0.0 >= .coinX_1
  0.0 >= .coinY_1
  (float2 .coinX_1 .coinY_1) >= .coin_position_1
  0.0 >= .coin_velocity_1

  ;; ----- Coin 2 ----
  0.0 >= .coinX_2
  0.0 >= .coinY_2
  (float2 .coinX_2 .coinY_2) >= .coin_position_2
  0.0 >= .coin_velocity_2

  ;; ----- Coin 3----
  0.0 >= .coinX_3
  0.0 >= .coinY_3
  (float2 .coinX_3 .coinY_3) >= .coin_position_3
  0.0 >= .coin_velocity_3

  ;; ----- Coin 4 ----
  0.0 >= .coinX_4
  0.0 >= .coinY_4
  (float2 .coinX_4 .coinY_4) >= .coin_position_4
  0.0 >= .coin_velocity_4

  0.5 >= .coin_acceleration)
;; -------------- Coin Animation ------------------
(defloop Coin_Animation
  .coin_image_index (Math.Add 1)
  > .coin_image_index
  (When :Predicate (IsMore .coin_image_index_max)
        :Action (-> 0 > .coin_image_index))

  (Pause .coin_Animation_Speed))

;; ------------- Coin Gravity ------------------
(defshards Coin_Gravity_Logic [coinY coinX coin_Velocity coin_Position]

  coinY (Math.Add coin_Velocity)
  > coinY

  coin_Velocity (Math.Add .coin_acceleration)
  > coin_Velocity

  (float2 coinX coinY) > coin_Position)

;; ------------- Random_Coin ------------------

(defshards Random_Coin_Logic [coinX coinY coin_Velocity coin_Position Pause_Length]
  coinX
  (RandomFloat :Max 1200.0)
  > coinX
  (Math.Subtract 600.0)
  > coinX

  0.0 > coinY
  0.0 > coin_Velocity
  (float2 coinX coinY) > coin_Position
  (Pause Pause_Length))

(defloop Random_Coin_Loop_1
  (Random_Coin_Logic .coinX_1 .coinY_1 .coin_velocity_1 .coin_position_1 1.5))

(defloop Random_Coin_Loop_2
  (Random_Coin_Logic .coinX_2 .coinY_2 .coin_velocity_2 .coin_position_2 2.5))

(defloop Random_Coin_Loop_3
  (Random_Coin_Logic .coinX_3 .coinY_3 .coin_velocity_3 .coin_position_3 3.5))

(defloop Random_Coin_Loop_4
  (Random_Coin_Logic .coinX_4 .coinY_4 .coin_velocity_4 .coin_position_4 5.5))

;; ------------ Spiked_CanonBalls ------------------
;; -------------------------------------
;; ------------ Innitialize Spiked CanonBalls ---------------
(defshards Innitialize_Spiked_CanonBalls []
  (LoadImage "GlodImages/SpikeBall/SpikeBall1.png") = .SpikeBall_1
  (LoadImage "GlodImages/SpikeBall/SpikeBall2.png") = .SpikeBall_2
  (LoadImage "GlodImages/SpikeBall/SpikeBall3.png") = .SpikeBall_3
  (LoadImage "GlodImages/SpikeBall/SpikeBall4.png") = .SpikeBall_4
  (LoadImage "GlodImages/SpikeBall/SpikeBall5.png") = .SpikeBall_5
  (LoadImage "GlodImages/SpikeBall/SpikeBall6.png") = .SpikeBall_6
  (LoadImage "GlodImages/SpikeBall/SpikeBall7.png") = .SpikeBall_7
  (LoadImage "GlodImages/SpikeBall/SpikeBall8.png") = .SpikeBall_8
  (LoadImage "GlodImages/SpikeBall/SpikeBall9.png") = .SpikeBall_9
  (LoadImage "GlodImages/SpikeBall/SpikeBall10.png") = .SpikeBall_10
  (LoadImage "GlodImages/SpikeBall/SpikeBall11.png") = .SpikeBall_11
  (LoadImage "GlodImages/SpikeBall/SpikeBall12.png") = .SpikeBall_12

  [.SpikeBall_1 .SpikeBall_2 .SpikeBall_3  .SpikeBall_4 .SpikeBall_5 .SpikeBall_6
   .SpikeBall_7 .SpikeBall_8 .SpikeBall_9 .SpikeBall_10 .SpikeBall_11 .SpikeBall_12]
  >= .SpikeBall_Array

  (Count .SpikeBall_Array) (Math.Subtract 1) >= .SpikeBall_Array_Index_Max
  0 >= .SpikeBall_Index
  0.06 >= .SpikeBall_Animation_Speed

  ;; ---------- SpikeBall_1 -------------
  1.0 >= .SpikeBall_Velocity_1
  0.0 >= .SpikeBall_Y_1
  0.0 >= .SpikeBall_X_1
  (float2 .SpikeBall_X_1 .SpikeBall_Y_1) >= .SpikeBall_Position_1

  ;; ---------- SpikeBall_2 -------------
  1.0 >= .SpikeBall_Velocity_2
  0.0 >= .SpikeBall_Y_2
  0.0 >= .SpikeBall_X_2
  (float2 .SpikeBall_X_2 .SpikeBall_Y_2) >= .SpikeBall_Position_2

  ;; ---------- SpikeBall_3 -------------
  1.0 >= .SpikeBall_Velocity_3
  0.0 >= .SpikeBall_Y_3
  0.0 >= .SpikeBall_X_3
  (float2 .SpikeBall_X_3 .SpikeBall_Y_3) >= .SpikeBall_Position_3

  0.5 >= .SpikeBall_Acceleration)

;;------------- Spiked CanonBall Animation
(defloop Spiked_CanonBall_Animation
  .SpikeBall_Index (Math.Add 1)
  > .SpikeBall_Index
  (When :Predicate (IsMore .SpikeBall_Array_Index_Max)
        :Action (-> 0 > .SpikeBall_Index))

  (Pause .SpikeBall_Animation_Speed))

;; ------------- SpikeBall_Gravity -------------
(defshards SpikeBall_Gravity_Logic [SpikeBall_Y SpikeBall_Velocity SpikeBall_Position SpikeBall_X]
  SpikeBall_Y (Math.Add SpikeBall_Velocity)
  > SpikeBall_Y
  SpikeBall_Velocity (Math.Add .SpikeBall_Acceleration)
  > SpikeBall_Velocity
  (float2 SpikeBall_X SpikeBall_Y) > SpikeBall_Position)

;; ------------ Randomise Spiked CanonBall Logic --------------
(defshards Randomise_SpikeBall_Logic [SpikeBall_X SpikeBall_Y SpikeBall_Velocity SpikeBall_Position PauseFloat]
  ;;RandomX
  SpikeBall_X
  (RandomFloat :Max 1200.0)
  > SpikeBall_X
  (Math.Subtract 600.0)
  > SpikeBall_X

  0.0 > SpikeBall_Y
  0.0 > SpikeBall_Velocity
  (float2 SpikeBall_X SpikeBall_Y) > SpikeBall_Position
  .SpikeBall_X_1
  (Pause PauseFloat))

(defloop SpikeBall_1
  (Randomise_SpikeBall_Logic .SpikeBall_X_1 .SpikeBall_Y_1 .SpikeBall_Velocity_1 .SpikeBall_Position_1 2))
(defloop SpikeBall_2
  (Randomise_SpikeBall_Logic .SpikeBall_X_2 .SpikeBall_Y_2 .SpikeBall_Velocity_2 .SpikeBall_Position_2 3))
(defloop SpikeBall_3
  (Randomise_SpikeBall_Logic .SpikeBall_X_3 .SpikeBall_Y_3 .SpikeBall_Velocity_3 .SpikeBall_Position_3 4))

;; ------------- SpikeBall_Collision_Logic --------------
(defshards SpikeBall_Collision_Logic [SpikeBall_X SpikeBall_Y] 
  
  SpikeBall_X 
  (If :Predicate (-> (IsLess .DamageUpper_X_Limit)
                     (And)
                     SpikeBall_X (IsMore .DamageLower_X_Limit)
                     (And)
                     SpikeBall_Y (IsLess .DamageUpper_Y_Limit)
                     (And)
                     SpikeBall_Y (IsMore .DamageLower_Y_Limit))

      :Then (-> .Damaged
                (When :Predicate (Is false)
                      :Action (->
                               true > .Damaged
                               (Log "Damaged: "))))))

;; -------------- SpikeBall_Damage_Logic --------------
(defshards SpikeBall_Damage_Logic []
  
  .X (Math.Add 120.0)
  >= .DamageUpper_X_Limit
  .X (Math.Subtract 120.0)
  >= .DamageLower_X_Limit

  .Y (Math.Add 15.0)
  >= .DamageUpper_Y_Limit
  .Y (Math.Subtract 15.0)
  >= .DamageLower_Y_Limit

  (SpikeBall_Collision_Logic .SpikeBall_X_1 .SpikeBall_Y_1)
  (SpikeBall_Collision_Logic .SpikeBall_X_2 .SpikeBall_Y_2)
  (SpikeBall_Collision_Logic .SpikeBall_X_3 .SpikeBall_Y_3)

  .Damaged
  (When :Predicate (Is true)
        :Action (->
                 .Score (Math.Subtract 1)
                 > .Score
                 false > .Damaged)))

;; ------------ Game Elements ------------------
;; -------------------------------------
;; ------------ Innitialize_GameElements---------------

(defshards Innitialize_GameElements []
  0 >= .Score

  ;; ----------- Score ------------
  .X (Math.Add 50.0)
  >= .ScoringUpper_X_Limit
  .X (Math.Subtract 50.0)
  >= .ScoringLower_X_Limit

  .Y (Math.Add 10.0)
  >= .ScoringUpper_Y_Limit
  .Y (Math.Subtract 10.0)
  >= .ScoringLower_Y_Limit

  ;; ---------- Damage ------------
  .X (Math.Add 50.0)
  >= .DamageUpper_X_Limit
  .X (Math.Subtract 50.0)
  >= .DamageUpper_X_Limit

  .Y (Math.Add 5.0)
  >= .DamageUpper_Y_Limit
  .Y (Math.Subtract 5.0)
  >= .DamageUpper_Y_Limit

  false >= .Scored
  false >= .Damaged)

;; ------------ Scoring ------------------
;; -------------------------------------
;; ------------ Score_Collision_Box ---------------
(defshards Score_Collision [coinX coinY]
  coinX
  (When :Predicate (->
                    (IsLess .ScoringUpper_X_Limit)
                    (And)
                    coinX (IsMore .ScoringLower_X_Limit)
                    (And)
                    coinY (IsLess .ScoringUpper_Y_Limit)
                    (And)
                    coinY (IsMore .ScoringLower_Y_Limit))
        :Action (->
                 .Scored
                 (When :Predicate (Is false)
                       :Action (->
                                true > .Scored
                                (Log "Scored: ")
                                )))))

;; ---------- Scoring using Score_Collision_Box ------------
(defshards Scoring []
  .X (Math.Add 50.0)
  > .ScoringUpper_X_Limit
  .X (Math.Subtract 50.0)
  > .ScoringLower_X_Limit

  .Y (Math.Add 10.0)
  > .ScoringUpper_Y_Limit
  .Y (Math.Subtract 10.0)
  > .ScoringLower_Y_Limit

  (Score_Collision .coinX_1 .coinY_1)
  (Score_Collision .coinX_2 .coinY_2)
  (Score_Collision .coinX_3 .coinY_3)
  (Score_Collision .coinX_4 .coinY_4)

  .Scored
  (When :Predicate (Is true)
        :Action (->
                 .Score (Math.Add 1)
                 > .Score
                 false > .Scored
                 (Log "Scored: "))))


;; ------ UI Style --------
(def style
  {:override_text_style "MyStyle"
   :text_styles
   [{:name "MyStyle"
     :size (float 46)
     :family "Monospace"}]
   :visuals
   {:override_text_color (color 250 250 250)}})

;; ----------- Main-Wire -----------

(defloop main-wire
  (Setup
   (Innitialize_Character)
   (Innitialize_Coin)
   (Innitialize_GameElements)
   (Innitialize_Spiked_CanonBalls))

  (Run_Logic)
  (Gravity_Logic)
  (Character_Boundary)

  (Coin_Gravity_Logic .coinY_1 .coinX_1 .coin_velocity_1 .coin_position_1)
  (Coin_Gravity_Logic .coinY_2 .coinX_2 .coin_velocity_2 .coin_position_2)
  (Coin_Gravity_Logic .coinY_3 .coinX_3 .coin_velocity_3 .coin_position_3)
  (Coin_Gravity_Logic .coinY_4 .coinX_4 .coin_velocity_4 .coin_position_4)
  (Step  Random_Coin_Loop_1)
  (Step  Random_Coin_Loop_2)
  (Step  Random_Coin_Loop_3)
  (Step  Random_Coin_Loop_4)
  
  (SpikeBall_Gravity_Logic .SpikeBall_Y_1 .SpikeBall_Velocity_1 .SpikeBall_Position_1 .SpikeBall_X_1)
  (SpikeBall_Gravity_Logic .SpikeBall_Y_2 .SpikeBall_Velocity_2 .SpikeBall_Position_2 .SpikeBall_X_2)
  (SpikeBall_Gravity_Logic .SpikeBall_Y_3 .SpikeBall_Velocity_3 .SpikeBall_Position_3 .SpikeBall_X_3)
  (Step  SpikeBall_1)
  (Step  SpikeBall_2)
  (Step  SpikeBall_3)
  
  (Scoring)
  (SpikeBall_Damage_Logic)
  
  

  (Step Walking_Animation)
  (Step Idle_Animation_Left)
  (Step Coin_Animation)
  (Step Spiked_CanonBall_Animation)

  (GFX.MainWindow
   :Title "MainWindow" :Width 1920 :Height 1080
   :Contents (-> (Setup
                  (GFX.DrawQueue) >= .ui-draw-queue
                  (GFX.UIPass .ui-draw-queue) >> .render-steps)
                 .ui-draw-queue (GFX.ClearQueue)

                 (UI
                  .ui-draw-queue
                  (->
                   (UI.Area :Position .Character_Position
                            :Anchor Anchor.Top
                            :Contents (->

                                         ;; ------------ Draw Character Idle --------------- 
                                       .CharacterIdle
                                       (If :Predicate (->  (Is true)
                                                           (And)
                                                           .Character_Walking_Left (Is false)
                                                           (And)
                                                           .Character_Walking_Right (Is false)
                                                           (And)
                                                           .Character_Jump (Is false)
                                                           (And)
                                                           .Character_Direction (Is 1)
                                                           (And)
                                                           .IsJumping (Is false))
                                           :Then (-> .idle_Right_image_array (Take .idle_image_index) (UI.Image :Scale (float2 0.2))))

                                       .CharacterIdle
                                       (If :Predicate (->  (Is true)
                                                           (And)
                                                           .Character_Walking_Left (Is false)
                                                           (And)
                                                           .Character_Walking_Right (Is false)
                                                           (And)
                                                           .Character_Jump (Is false)
                                                           (And)
                                                           .Character_Direction (Is -1)
                                                           .IsJumping (Is false))
                                           :Then (-> .idle_Left_image_array (Take .idle_image_index) (UI.Image :Scale (float2 0.2))))


                                         ;; ------------- Draw Character Walking ---------------- 
                                       .CharacterIdle
                                       (If :Predicate (->  (Is false)
                                                           (And)
                                                           .Character_Walking_Left (Is true)
                                                           (And)
                                                           .Character_Walking_Right (Is false)
                                                           (And)
                                                           .Character_Jump (Is false)
                                                           (And)
                                                           .IsJumping (Is false))
                                           :Then (-> .walking_Left_image_array (Take .walking_image_index) (UI.Image :Scale (float2 0.2))))


                                       .CharacterIdle
                                       (If :Predicate (->  (Is false)
                                                           (And)
                                                           .Character_Walking_Left (Is false)
                                                           (And)
                                                           .Character_Walking_Right (Is true)
                                                           (And)
                                                           .Character_Jump (Is false)
                                                           (And)
                                                           .IsJumping (Is false))
                                           :Then (-> .walking_Right_image_array (Take .walking_image_index) (UI.Image :Scale (float2 0.2))))

                                         ;; ------------- Draw Character Jumping ---------------- 
                                       .IsJumping
                                       (If :Predicate (->  (Is true)
                                                           (And)
                                                           .Character_Direction (Is 1))
                                           :Then (-> .Character_Jumping_Right (UI.Image :Scale (float2 0.2))))

                                       .IsJumping
                                       (If :Predicate (->  (Is true)
                                                           (And)
                                                           .Character_Direction (Is -1))
                                           :Then (-> .Character_Jumping_Left (UI.Image :Scale (float2 0.2))))))

                   ;; ------------- Coins UI.Area ------------------

                   (UI.Area :Position .coin_position_1
                            :Anchor Anchor.Top
                            :Contents (->
                                       .coin_image_array (Take .coin_image_index) (UI.Image :Scale (float2 0.2))))

                   (UI.Area :Position .coin_position_2
                            :Anchor Anchor.Top
                            :Contents (->
                                       .coin_image_array (Take .coin_image_index) (UI.Image :Scale (float2 0.2))))

                   (UI.Area :Position .coin_position_3
                            :Anchor Anchor.Top
                            :Contents (->
                                       .coin_image_array (Take .coin_image_index) (UI.Image :Scale (float2 0.2))))

                   (UI.Area :Position .coin_position_4
                            :Anchor Anchor.Top
                            :Contents (->
                                       .coin_image_array (Take .coin_image_index) (UI.Image :Scale (float2 0.2))))

                   ;; -------- Spiked CanonBall UI.Area ----------
                   (UI.Area :Position .SpikeBall_Position_1
                            :Anchor Anchor.Top
                            :Contents (->
                                       .SpikeBall_Array (Take .SpikeBall_Index) (UI.Image :Scale (float2 0.15))))
                   
                   (UI.Area :Position .SpikeBall_Position_2
                            :Anchor Anchor.Top
                            :Contents (->
                                       .SpikeBall_Array (Take .SpikeBall_Index) (UI.Image :Scale (float2 0.15))))
                   
                   (UI.Area :Position .SpikeBall_Position_3
                            :Anchor Anchor.Top
                            :Contents (->
                                       .SpikeBall_Array (Take .SpikeBall_Index) (UI.Image :Scale (float2 0.15))))

                   ;; ---------- Game UI -------------
                   (UI.Area :Position (float2 -40 20)
                            :Anchor Anchor.TopRight
                            :Contents (->
                                       style (UI.Style)
                                       .Score (ToString) (UI.Label)))))

                 (GFX.Render :Steps .render-steps)

                 (Button_Inputs))))


(defmesh main)
(schedule main main-wire)
(run main (/ 1.0 60))