(defshards Initialize []
  ;; Jumping Sprites
  (LoadImage "GlodImages/Character1_Jumping.png") = .image_jumping
  (LoadImage "GlodImages/Character1_Jumping_Left.png") = .image_jumping_Left

  ;; Idle Sprites (Facing Right)
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_1.png") = .image_idle_1
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_2.png") = .image_idle_2
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_3.png") = .image_idle_3
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_4.png") = .image_idle_4
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_5.png") = .image_idle_5
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_6.png") = .image_idle_6
  (LoadImage "GlodImages/Character_Idle/Idle_Right/Character1_Idle_7.png") = .image_idle_7
  [.image_idle_1 .image_idle_2 .image_idle_3 .image_idle_4 .image_idle_5 .image_idle_6 .image_idle_7] >= .idle_image_array

  ;;Idle Sprites (Facing Left)
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_1.png") = .image_idle_Left_1
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_2.png") = .image_idle_Left_2
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_3.png") = .image_idle_Left_3
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_4.png") = .image_idle_Left_4
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_5.png") = .image_idle_Left_5
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_6.png") = .image_idle_Left_6
  (LoadImage "GlodImages/Character_Idle/Idle_Left/Character1_Idle_Left_7.png") = .image_idle_Left_7
  [.image_idle_Left_1 .image_idle_Left_2 .image_idle_Left_3 .image_idle_Left_4 .image_idle_Left_5 .image_idle_Left_6 .image_idle_Left_7] >= .idle_Left_image_array
  (Count .idle_image_array) (Math.Subtract 1) >= .idle_image_index_max
  0 >= .idle_image_index
  0.08 >=  .Idle_Animation_Speed ;; Reduce number to increase animation speed

  ;; Walking Sprites (Facing Right)
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_1.png") = .image_walking_1
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_2.png") = .image_walking_2
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_3.png") = .image_walking_3
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_4.png") = .image_walking_4
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_5.png") = .image_walking_5
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_6.png") = .image_walking_6
  (LoadImage "GlodImages/Character_Walking/Walking_Right/Character1_Walking_7.png") = .image_walking_7
  [.image_walking_1 .image_walking_2 .image_walking_3 .image_walking_4 .image_walking_5 .image_walking_6 .image_walking_7] >= .walking_image_array

  ;; Walking Sprites (Facing Left)
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_1.png") = .image_walking_Left_1
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_2.png") = .image_walking_Left_2
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_3.png") = .image_walking_Left_3
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_4.png") = .image_walking_Left_4
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_5.png") = .image_walking_Left_5
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_6.png") = .image_walking_Left_6
  (LoadImage "GlodImages/Character_Walking/Walking_Left/Character1_Walking_Left_7.png") = .image_walking_Left_7
  [.image_walking_Left_1 .image_walking_Left_2 .image_walking_Left_3 .image_walking_Left_4 .image_walking_Left_5 .image_walking_Left_6 .image_walking_Left_7] >= .walking_Left_image_array
  (Count .walking_image_array) (Math.Subtract 1) >= .walking_image_index_max
  0 >= .walking_image_index
  0.08 >= .Walking_Animation_Speed ;; Reduce number to increase animation speed

  0.0 >= .X ;; X coordinate of Character Position
  0.0 >= .Y ;; Y coordinate of Character Position
  (Float2 .X .Y) >= .CharacterPosition

  0.0 >= .Character_Velocity_y ;;jumping velocity, increase to make character jump higher
  0.0 >= .Character_Acceleration_y ;; jumping acceleration, increase to make character land faster, decrease to make character land slower
  0.0 >= .Character_Velocity_x ;; running speed, increase to make character run faster
  0.0 >= .Character_Acceleration_x ;; running acceleration (not implemented yet)

  1 >= .CharacterDirection ;; 1 for when it is facing Right, becomes -1 when it is facing left
  (float2 0.2 0.2) >= .CharacterScale ;; variable used inside UI.Image, just incase I want it to increase in size 

  true >= .CanJump ;; whether the character can jump. Only allow the character to jump when he is on land and prevents infinite jumping in air
  false >= .isJumping ;; whether the character is jumping
  false >= .isRunning ;; whether the character is jumping or no
  true >= .isIdle ;; whether the character is idle or no
  false >= .RunKeyDown ;;To check if the run button is being pressed 
  )

;;Idle Animation Function
(defloop Idle_Animation 
  .idle_image_index (Math.Add 1)
  > .idle_image_index
  (When :Predicate (IsMore .idle_image_index_max)
        :Action (-> 0 > .idle_image_index))
  (Pause .Idle_Animation_Speed)
  )

;;Walking Animation Function
(defloop Walking_Animation
  .walking_image_index (Math.Add 1)
  > .walking_image_index
  (When :Predicate (IsMore .walking_image_index_max)
        :Action (-> 0 > .walking_image_index))
  (Pause .Walking_Animation_Speed))


;; When up button is pressed, character jumps
(defshards Jump[]
  (Inputs.KeyDown
   :Key "up"
   :Action (->
            .CanJump
            (When :Predicate (Is true)
                  :Action (->
                           false > .isRunning
                           false > .CanJump
                           true > .isJumping
                           false > .isIdle
                           -20.0 > .Character_Velocity_y
                           1.0 > .Character_Acceleration_y)))))

;; When left or right button is pressed,character runs left or right
(defshards Run []
  (Inputs.KeyDown
   :Key "right"
   :Action (->
            false > .isIdle
            2.0 > .Character_Velocity_x
            1 > .CharacterDirection
            true > .RunKeyDown
            ;;1.0 > .Character_Acceleration_x
            
            .isJumping 
            (If :Predicate (Is false)
                :Then (->
                       true > .isRunning)
                :Else(->
                      false > .isRunning))))
  
  (Inputs.KeyDown
   :Key "left"
   :Action (->
            false > .isIdle
            -2.0 > .Character_Velocity_x
            -1 > .CharacterDirection
            true > .RunKeyDown
            ;;-1.0 > .Character_Acceleration_x

            .isJumping
            (If :Predicate (Is false)
                :Then (->
                       true > .isRunning)
                :Else (->
                       false > .isRunning))
            ))

  ;;when key is up go back into idle mode
  (Inputs.KeyUp
   :Key "right"
   :Action (->
            true > .isIdle
            false > .isRunning
            0.0 > .Character_Velocity_x
            0.0 > .Character_Acceleration_x
            false > .RunKeyDown))
  
  (Inputs.KeyUp
   :Key "left"
   :Action (->
            true > .isIdle
            false > .isRunning
            0.0 > .Character_Velocity_x
            0.0 > .Character_Acceleration_x
            false > .RunKeyDown)))

;; makes character jump and fallback down with gravity
(defshards Gravity []
  .Y
  (When :Predicate (IsMore (float 0.0))
        :Action (->
                 0.0 > .Character_Acceleration_y
                 0.0 > .Character_Velocity_y
                 0.0 > .Y
                 true > .CanJump
                 false > .isJumping
                 .RunKeyDown
                 (If :Predicate (Is true)
                     :Then (->
                            true > .isRunning)
                     :Else (->
                            true > .isIdle))))
  
  .Y (Math.Add .Character_Velocity_y)
  > .Y
  .Character_Velocity_y (Math.Add .Character_Acceleration_y)
  > .Character_Velocity_y
  .Y
  > (Float2 .X .Y) >= .CharacterPosition
  )

(defshards Friction[]
  .X (Math.Add .Character_Velocity_x)
  > .X
  .Character_Velocity_x (Math.Add .Character_Acceleration_x)
  > .Character_Velocity_x
  .X
  > (Float2 .X .Y) >= .CharacterPosition
  )

;; ensures no duplicate sprites are displayed on screen
(defshards Animation_Limiters []
  .isJumping
  (When :Predicate (Is true)
        :Action (->
                 false > .isRunning
                 false > .isIdle))
  .isRunning
  (When :Predicate (Is true)
        :Action (->
                 false > .isIdle)))

(defloop main-wire
  (Setup
   (Initialize)) 
  
  (Animation_Limiters)
  
  (GFX.MainWindow
   :Title "TestWindow" :Width 1920 :Height 1080
   :Contents (-> (Setup
                  (GFX.DrawQueue) >= .ui-draw-queue
                  (GFX.UIPass .ui-draw-queue) >> .render-steps)
                 .ui-draw-queue (GFX.ClearQueue)

                 (UI
                  .ui-draw-queue
                  (->
                   (UI.Area
                    :Anchor Anchor.Bottom
                    :Contents
                    (->
                     .isJumping
                     (If :Predicate (Is true)
                         :Then (->
                                .CharacterDirection
                                (If :Predicate (Is 1)
                                    :Then (->
                                           .image_jumping (UI.Image :Scale .CharacterScale))
                                    :Else (->
                                         .image_jumping_Left (UI.Image :Scale .CharacterScale)))))

                     .isRunning
                     (If :Predicate (Is true)
                         :Then (->
                                (Step Walking_Animation)
                                .CharacterDirection
                                (If :Predicate (Is 1)
                                    :Then (->
                                           .walking_image_array (Take .walking_image_index) (UI.Image :Scale .CharacterScale))
                                    :Else (->
                                           .walking_Left_image_array (Take .walking_image_index) (UI.Image :Scale .CharacterScale)))))

                     .isIdle
                     (If :Predicate (Is true)
                         :Then (->
                                (Step Idle_Animation)
                                .CharacterDirection
                                (If :Predicate (Is 1)
                                    :Then (->
                                           .idle_image_array (Take .idle_image_index) (UI.Image :Scale .CharacterScale))
                                    :Else (->
                                           .idle_Left_image_array (Take .idle_image_index) (UI.Image :Scale .CharacterScale)))))))))

                 (Jump)
                 (Gravity)
                 (Run)
                 (Friction)

                 (GFX.Render :Steps .render-steps))))

(defmesh main)
(schedule main main-wire)
(run main (/ 1.0 60))