;; ############### jumping protos ####################
;; #######################################################

;; ----- initialising y velocity & acceleration
(defwire initialise-jump
  0.0 >== .character-y-velocity
  0.0 >== .character-y-acceleration
  true >== .can-jump)

;; ---- character y limits ----
;;[y-min y-max]
(defwire initialise-character-y-limits
  (| (Take 0) (ToFloat) >== .y-min)
  (| (Take 1) (ToFloat) >== .y-max))

;; ---- actual jump logic ----
;; (float 2) .animation-position
(defwire character-jump-plus-gravity
  (| (Take 0) (ToFloat) > .x-position)
  (| (Take 1) (ToFloat) > .y-position)

  .y-position (Math.Subtract .character-y-velocity)
  > .y-position

  .character-y-velocity (Math.Subtract .character-y-acceleration)
  > .character-y-velocity

  .y-position > (Max .y-min) (Min .y-max) > .y-position

  (float2 .x-position .y-position))
;; > .animation-position

;; ---- when character is on the ground reset stuff ----
[.y-position .y-limit]
(defwire character-on-ground
  (| (Take 0) (ToFloat) >= .temp-y)
  (| (Take 1) (ToFloat) >= .temp-y-limit)

  .temp-y
  (When :Predicate (Is .temp-y-limit)
        :Action (->
                 0.0 > .character-y-velocity
                 0.0 > .character-y-acceleration
                 true > .can-jump)))


;; ---- jump button ----
;;[character-y-velocity character-y-acceleration]
(defwire character-jump-button
  (| (Take 0) (ToFloat) >= .temp-velocity)
  (| (Take 1) (ToFloat) >= .temp-acceleration)

  (Inputs.KeyDown
   :Key "up"
   :Action (->
            .can-jump
            (When :Predicate (Is true)
                  :Action (->
                           .temp-velocity > .character-y-velocity
                           .temp-acceleration >  .character-y-acceleration
                           false > .can-jump)))))